<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DB relational db comparison</title>
    <url>/code-blog/2022/09/29/DB_relational_db_comparion/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>開始進入DB的範圍，DB目前分兩類，SQL及No SQL，No SQL並不真的算是一種種類，他比較算是集合，所以兩者的意思說起來應該是:</p>
<blockquote>
<p>SQL DB跟那些不是SQL的DB</p>
</blockquote>
<p>SQL也就是今天要聊的relational DB到底有什麼了不起的地方，竟然讓除了他以外的DB都被分成一類。<br>這就是好像有天有人跟你說，這世界上的飲料只分成烏弄跟不是烏弄得一樣XD</p>
<p>另外其實SQL裡面也分了很多不同的DB，那他們有什麼樣相同的特性，讓他們既是不同的DB卻被通稱為SQL DB呢?<br>我們今天也會稍微看看他們彼此的特色~</p>
<h2 id="什麼是關聯式資料庫relational-db-RDB"><a href="#什麼是關聯式資料庫relational-db-RDB" class="headerlink" title="什麼是關聯式資料庫relational db(RDB)?"></a>什麼是關聯式資料庫relational db(RDB)?</h2><blockquote>
<p>關聯資料庫 (RDB) 是在資料表、資料列和資料欄中建構資訊的方式。RDB 可透過彙整資料表來建立資訊之間的關聯或關係，以便輕鬆瞭解各資料點之間的關係並取得深入分析。<br>– <a href="https://cloud.google.com/learn/what-is-a-relational-database">Google</a></p>
</blockquote>
<p>relational db將資料整合成行row跟欄column，多個row會集合成一個表table，多個table就會組成一個db。<br>table通常都會設定一個主鍵primary key(PK)的欄位代表該row，就好像一個大學裡面的學號一樣，每個人都不會重複。<br>table之間在需要存在類似資料時會以其他table的PK作為代表，稱為外鍵foreign key(FK)，就好比今天有入學文件，文件有文件的編號，文件上會寫著學生的學號。<br>透過PK和FK可以表現table之間的關係，以剛剛舉例，一個學生可能同時有很多份文件，每分文件只屬於一個學生，那學生與文件的關係就是一對多。</p>
<p>通常關聯式資料庫也代表他具有交易(事務)特性，具有這樣的特性代表他可以具有一個最小的執行單位稱為「交易」(Transaction)，在這個交易可能包含多個對資料庫操作的行為，並且這個交易是全有全無的。</p>
<p>另外relational db manager system(RDBMS)指的是管理RDB的系統，可以把他理解成是RDB的介面~</p>
<h2 id="什麼是SQL"><a href="#什麼是SQL" class="headerlink" title="什麼是SQL?"></a>什麼是SQL?</h2><p>SQL全名叫做結構話查詢語言Structured Query Language，專門用來與關聯式資料庫溝通的程式語言。<br>也正因為這樣，所以關聯式資料庫也常被稱為SQL資料庫。</p>
<p>而前面曾經說到SQL其實還有很多細微分支，但因為他們也是以RDB的概念管理資料，並且都能使用SQL和RDBMS溝通，所以也都被稱為SQL DB。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>原本是想要做一些對於DB的比較，但後來發現，能夠做出比較，已經是對該DB有不少研究或是已經有相關經驗。<br>所以那部分就沈船了。</p>
<p>但多少有點收穫是，發現一個常被拿來做效能量化數據的單位稱為TPC，他們有許多不同情境的測試，是一個值得作為參考的數據來源。<br>另外也發現，常會拿來比較的一些項目包括: 成本(學習、費用)、效能、安全性、擴充性。<br>不過針對效能這點，以別人做得比較來看，與其說誰最好，不如說誰相對最好會來的更準確一些。</p>
<p>最後就提供一些我找到的比較文章僅做紀念吧。</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10206222">[Day15] 資料庫 - 介紹與比較</a></li>
<li><a href="http://caryhsu.blogspot.com/2011/06/sql-server-vs-oracle-and-mysql.html">不同資料庫的比較 - SQL Server vs Oracle and MySQL</a></li>
<li><a href="https://faq.postgresql.tw/postgresql-vs-mysql-vs-sql-server-vs-oracle">PostgreSQL vs MySQL vs SQL Server vs Oracle</a></li>
</ul>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.ibm.com/cloud/learn/relational-databases">Relational Databases</a><br><a href="https://oldmo860617.medium.com/database-transaction-acid-156a3b75845e">Database Transaction &amp; ACID</a><br><a href="https://www.edx.org/course/databases-5-sql">Databases: Relational Databases and SQL</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>RDBMS</tag>
        <tag>RDB</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>瀏覽器(Browser)與他們的產地-瀏覽器是怎麼運作的?</title>
    <url>/code-blog/2022/09/18/Network_Browser/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這邊將提及的是，當我們在瀏覽器的搜尋欄中輸入一串網址<code>https://ithelp.ithome.com.tw/</code>時，在瀏覽器的背後到底發生了什麼事情?</p>
<p>稍稍了解這個部分，對於開發者在開發符合使用者需求的網站-快速渲染網頁、交互溝通順暢，是會帶來幫助的；甚至當網頁出現問題或效率不彰的時候，透過對於瀏覽器運作機制的了解，也能對糾錯帶來一定的幫助。</p>
<p>不過因為這邊主要側重後端的角度上，瀏覽器溝通的前面步驟導航其實就是典型的HTTP溝通，也是後端常會接觸到的範圍，所以這部分會多些篇幅，而在解析、渲染的部分等關於畫面的部分就會說得相對少很多XD。</p>
<p>那就開始今天的部分吧!!</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>透過MDN的分類，可以將這段流程分為以下幾段</p>
<ol>
<li>導航Navigation: 建立與Server連線</li>
<li>回應Response: 發出請求並得到回應</li>
<li>解析Parsing: 解析回應</li>
<li>渲染Render: 渲染畫面</li>
<li>交互Interactivity: 與使用者互動</li>
</ol>
<h2 id="導航"><a href="#導航" class="headerlink" title="導航"></a>導航</h2><p>此部分將完成的工作是透過傳輸層與Server建立連線。</p>
<p>這部份我們會先以HTTP&#x2F;2.0之前作為範例，在前一天已經有提到過HTTP&#x2F;3會使用不同的傳輸層協定，有興趣可以再回頭看一下。</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10292700">超文本傳輸協定(HTTP)是什麼?</a></li>
</ul>
<h3 id="網域名稱系統Domain-Name-System-DNS"><a href="#網域名稱系統Domain-Name-System-DNS" class="headerlink" title="網域名稱系統Domain Name System(DNS)"></a>網域名稱系統Domain Name System(DNS)</h3><p>在瀏覽器與OS溝通完畢要進行與目標網址的對話後，第一步要做的就是與DNS溝通取得正確ip位置，在談及DNS時，我們稍微談一下網址，並以<code>https://ithelp.ithome.com.tw/</code>作為範例，網址結構上分為:</p>
<ol>
<li>傳輸協定Protocol: <code>https://</code></li>
<li>主機&#x2F;網域Host&#x2F;Domain: <code>ithelp.ithome.com.tw</code></li>
<li>路徑Path: <code>/</code></li>
</ol>
<p>接著，我們目前僅需要知道的部分是，目前可讀的網域其實僅是一種對照，他會被對照到一個真實的ip，好處包括彈性(可以隨意變換Domain背後的ip)、易讀易記等。</p>
<p>而要怎麼透過Domain去找到真實的ip，這個就是DNS工作的範疇了，詳情我就不解釋，這是明天的主題XD</p>
<h3 id="TCP連線"><a href="#TCP連線" class="headerlink" title="TCP連線"></a>TCP連線</h3><p>在得知ip位置之後，會進行經典的TCP三次握手(TCP 3-way Handshake)，其目的是為了確保連接的正確性，包含SYN, SYN-ACK, ACK。</p>
<p>A及B分別代表Client及Server, 而三次握手分別完成的工作包括有:</p>
<ol>
<li>同步Sync: 由A發出，讓Server知道我們的TCP設置。</li>
<li>同步確認Sync Check: 由B發出，回應Client他已經收到訊息並準備建立連線進行通信。</li>
<li>確認Check: 由A再度發出，表示完成連線。</li>
</ol>
<p>在這裡我當時自問了一個有趣的小問題: 為什麼需要第三次確認才算建立連線呢?<br>這邊找到了一個解釋: </p>
<blockquote>
<p>一句話，主要防止已經失效的連接請求報文突然又傳送到了服務器，從而產生錯誤。 – <a href="https://blog.csdn.net/qzcsu/article/details/72861891">兩張動圖-徹底明白TCP的三次握手與四次揮手</a><br>————————————————<br>版权声明：本文为CSDN博主「小书go」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
</blockquote>
<p>他的原意是為了避免產生錯誤且不必要的連結，假設是二次握手好了: </p>
<ol>
<li>比如連接X請求SYN送出，雖沒丟失但因為某些原因被延誤。</li>
<li>A因為遲遲沒收到SYN-ACK誤以為連接請求丟失就重發連接請求Y。</li>
<li>重發後完成二次握手，在完成request-response後關閉連線。</li>
<li>此時連接請求X總算到了B，B發回SYN-ACK</li>
<li>A在收到訊息後就又建立了新的連線了。</li>
</ol>
<p>作為旁觀者的我們知道這個步驟5的連接其實是不必要的損耗，為了避免這個損耗，於是就出現了三次握手，我們回到原本的過程5。</p>
<ol start="5">
<li>此時SYN-ACK回到A，A這邊有資訊知道這個連接是不用被建立的，就不會再回傳一次ACK給B</li>
<li>B在收不到ACK的狀況下，就也可以知道這個連接是不用被建立的。</li>
</ol>
<h3 id="SSL-x2F-TLS握手"><a href="#SSL-x2F-TLS握手" class="headerlink" title="SSL&#x2F;TLS握手"></a>SSL&#x2F;TLS握手</h3><p>基於安全的需求，在TCP之上又多出了一層SSL&#x2F;TLS安全協定，於是當我們使用HTTPS的網址時就會多出這段過程，其目的在於讓端點雙方溝通的訊息僅能被彼此看懂，這也會在後面的鐵人賽在多加敘述XD。</p>
<h2 id="回應Response"><a href="#回應Response" class="headerlink" title="回應Response"></a>回應Response</h2><p>總算完成連接之後，就會開始進行HTTP的Request-Response過程，輸入在網址欄的網址，會作為GET請求被發出，更準確來說，瀏覽器會替你發出一條HTTP報文並請求Server回覆。</p>
<h2 id="解析Parsing、渲染Render、交互性Interactivity"><a href="#解析Parsing、渲染Render、交互性Interactivity" class="headerlink" title="解析Parsing、渲染Render、交互性Interactivity"></a>解析Parsing、渲染Render、交互性Interactivity</h2><p>在收到<code>https://ithelp.ithome.com.tw</code>回應的網頁資料之後，接著就是開始將資料做解析。<br>其過程根據不同的瀏覽器，有不同的渲染引擎，像是Chrome使用的是開源引擎WebKit的分支Blink，FireFox使用的則是Gecko，解析的流程略有不同，但概念的大方向其實是接近的。</p>
<ol>
<li>將HTML轉換成DOM tree，CSS轉換成CSSOM tree</li>
<li>將兩者計算並建立Render Tree</li>
<li>Layout過程，為每個Render tree的節點決定在螢幕上的確切座標</li>
<li>遍歷Render Tree的節點，使用UI後端繪製畫面。</li>
</ol>
<p>在完成畫面繪製後，畫面就可以與使用者互動了。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>還有好些地方可以深入研究，包括解析、渲染、交互之後的TCP關閉連線，甚至是HTTP&#x2F;3的QUIC連線都有深入可以理解的部分。</p>
<p>不過透過對於這些內容的理解究竟可以做些什麼呢?</p>
<p>來舉一些例子好了，從比較底層的來看，當我們知道SSL&#x2F;TLS是作為安全性的增強而產生的協議，並且知道他產生了多次的RTT(封包往返時間)，如果未來網頁溝通效率很遭，有可能可以以此猜測瓶頸出現在哪。</p>
<p>另外一個比較實際的角度，我們的網頁有可能突然掛掉，並收到伺服器回饋表示DNS parsing fail，這時候或許就不是一籌莫展，我們因為知道DNS僅代表ip的映射，若有些重大服務&#x2F;第三方服務，在考量之下也可以請對方先以真實ip代替迴避重大損失。</p>
<p>大概就是這樣囉，明天我們會稍稍深入DNS，了解到我們的DN是怎麼被映射回ip的，明天見~</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://web.dev/howbrowserswork/">How Browsers Work</a><br><a href="https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/">Traffic example</a><br><a href="https://bbs.huaweicloud.com/blogs/314817">TCP壅塞控制機制</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">MDN-How_browsers_work</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>自己家的地址自己取-網域(domain) v.s. 網域名稱系統(domain name system)</title>
    <url>/code-blog/2022/09/19/Network_DNS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>域名讓網頁的ip地址轉變成能夠被人類理解的內容，根據維基百科的資料，到2022年已經有超過5億的域名登記註冊。</p>
<p>今天要稍微深入看一下Domain name這個部分的內容，內容應該會包含域名的結構、域名系統(DNS)如何在client要求與建立連線時將正確的ip交付。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>可理解性: 比IP位置更好被記億。</li>
<li>唯一性: 和IP位置一樣，域名也是唯一性的，同一個域名不會代表兩個不同的IP位置，另外，因為他是映射的IP位置可以被更改，你可以隨意修改你的DN對應到的服務器IP位置。</li>
</ol>
<h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><p>一個域名可以由好幾個字串組成，這些字串被點(.)分隔，而最右邊的字串被稱為頂級域名Top-Level Domain(TLD)。</p>
<p>頂級域名可以大致分為國家和地區頂級域(ccTLD)以及通用頂級域(gTLD)，ccTLD就像是台灣的tw結尾，而gTLD通常具有特定意義代表多個組織，例如gov(政府)、edu(教育機構)、com(商業)…等等</p>
<p>頂級域名往左就會被稱為子域名，由二級開始，每向左多出一個域名就會下降一層，三級、四級…等等。</p>
<h2 id="DNS機制"><a href="#DNS機制" class="headerlink" title="DNS機制"></a>DNS機制</h2><p>我們稍稍回到昨天，當我們輸入網址並按下ENTER後，在透過DNS取得正確的步驟包括以下:</p>
<ol>
<li>檢查本機的DNS緩存是否有保存IP位置。</li>
<li>假設並沒有緩存，現在要開始做DNS查詢。</li>
<li>DNS查詢首先會往此電腦被設定的DNS伺服器去查詢，我們在此處稱為本地伺服器。</li>
<li>若是符合該主機的本域名會直接回答，沒有的話也會檢查Cache看有沒有相關資料。</li>
<li>若依舊沒有的狀況，此本地DNS server會向此server有紀錄的根網域主機root domain name server(保管所有TLDNS的伺服器位置資料)發出請求。</li>
<li>該根網域主機會回傳一台控制該網域的DNS的ip位置。</li>
<li>在得到新的DNS IP後，本地DNS會向該DNS發出請求。</li>
<li>若並非為該DNS儲存的資料，則會回傳更靠近該網域的DNS server。</li>
<li>重複7, 8步驟直到收到正確ip為止</li>
</ol>
<p>從以上資訊我們可以得到一個結論是一台DNS並不會存放所有域名的DN資料，資料都是分別儲存在層層搜尋出來的。</p>
<p>唯一共用位置資料的只有前面提到的根網域伺服器，他們共用同一份根域(Root Zone file)檔案，裡面記錄著頂級域名權威伺服器的ip位置。</p>
<h2 id="有趣的小指令-whois"><a href="#有趣的小指令-whois" class="headerlink" title="有趣的小指令: whois"></a>有趣的小指令: whois</h2><p>linux的系統可以透過apt install whois安裝這個命令。</p>
<p>這個命令可以讓你查看指定網域的註冊資料，你也可以知道你查詢的網域是不是已經被使用了。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>還記得過往曾經看過一些文章和你說，修改DNS的位置可以加速你的網路讀取速度，現在想想，他的邏輯應該是，若你可以直接在第一層詢問local DNS就拿到你要的ip位置，就可以少等待很多時間。</p>
<p><img src="https://i.imgur.com/L6EtBWC.png" alt="windows DNS設定修改"></p>
<p>但換個方式來說，你的server或是你的電腦為了效率，其實也會將取得的IP做Cache，所以第二次連接相同網站速度還是無法提升時，也代表或許瓶頸並不是出現在DNS這段，對於排錯又可以多一些額外的資訊了。</p>
<p>今天差不多就到這裡囉，明天會聊聊託管(hoisting)</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_domain_name">MDN-Domain</a><br><a href="https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/">Traffic</a><br><a href="https://blog.twnic.tw/wp-content/uploads/2021/08/2021_jprs_ZH-TW_0830_final.pdf">網路大冒險</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>欸黑，我的主機不在我家-託管(hosting)</title>
    <url>/code-blog/2022/09/19/Network_hosting/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前幾天的主題大概已經描述一個輪廓Web: 一般而言我們使用瀏覽器作為client，透過HTTP，去與一台一個具有特定ip位置的server用GET方法取得網頁內容，並透過瀏覽器引擎渲染出網頁的畫面。</p>
<p>這邊我們用一個問題代入今天的主題: server都被放在哪裡?</p>
<p>事實上具有運算、儲存的設備都可以作為主機使用，但管理一台主機的成本還蠻高的，包括能源、維護甚至是因為流量變大而有的擴充需求。</p>
<p>所以出現了Hosting服務，也就是今天的主題，通常具有較大型的主機，也有專門的人進行維護，一般來說成本相對個人管理來的低，而這些託管商則透過規模化來減少成本獲取利潤。</p>
<p>今天會大概介紹託管的分類並舉一些對應的例子。</p>
<span id="more"></span>

<h2 id="分類"><a href="#分類" class="headerlink" title="分類"></a>分類</h2><p>常見的Hosting分類包括有:</p>
<ol>
<li>共享主機 shared hosting</li>
<li>虛擬專用伺服器 VPS hosting</li>
<li>專用主機 dedicated hosting</li>
<li>雲託管 cloud hosting</li>
</ol>
<p>前三者大部分的Hosting服務商都有提供，僅最後一個服務，受限於規模及技術，僅少數服務像是AWS, GCP, Azure</p>
<p>若讓我將Hosting各個類別做成雷達圖，它包含的取向包括: 資源隔離度、維運成本、單位費用。</p>
<p><img src="https://i.imgur.com/PkuEsMS.png"></p>
<p>那接下來我們就透過雷達圖一一來看一下不同的hosting模式及特性。<br>打個預防針，這裡的數字只是比較性的，有利用我們理解各個服務的差異而已XD</p>
<h2 id="共享主機-shared-hosting"><a href="#共享主機-shared-hosting" class="headerlink" title="共享主機 shared hosting"></a>共享主機 shared hosting</h2><ul>
<li>資源隔離度: 1</li>
<li>維運成本: 1</li>
<li>租借費用: 1</li>
<li>風險: 5</li>
<li>擴充性: 1</li>
</ul>
<p>共享主機指的是共享一台物理主機的所有資源，此處的資源包括網路、CPU、記憶體，雖然大部分會設定資源使用的最高限制，但不包括最低限制，常會發生「超賣」的狀況，意思是指，我們如果將該台物理主機上所有的網站的最高限制加起來會超過該台機器所能承擔的物理上限。</p>
<h3 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h3><p>這也是為什麼他那麼便宜，因為他的訂價本身就鎖定了一些資源消耗極低的網站的客戶，並且使用一些平衡資源使用的機制確保這樣的狀況不常發生。</p>
<p>二來通常這樣的服務提供全託管，除了上傳你的網站文件外不用再做額外的維運。</p>
<h3 id="壞處"><a href="#壞處" class="headerlink" title="壞處"></a>壞處</h3><p>但會產生的風險也顯而易見，當遇到小概率事件，比如網站的總資源占用已經達到了上限時，我們架設在上面的網站也會被影響。</p>
<p>另外他的擴充性幾乎可以無視，因為你的擴充還是受限於該物理主機的整體用量，若遇到大流量時還是會受到其他人的影響</p>
<h2 id="虛擬專用伺服器-VPS"><a href="#虛擬專用伺服器-VPS" class="headerlink" title="虛擬專用伺服器 VPS"></a>虛擬專用伺服器 VPS</h2><ul>
<li>資源隔離度: 3</li>
<li>維運成本: 2</li>
<li>租借費用: 3</li>
<li>風險: 4</li>
<li>擴充性: 3</li>
</ul>
<p>虛擬專用主機和Shared Hosting一樣共享一台主機的資源，但差別在於，你對於你所能用的資源掌握的是下限，代表你能夠擁有保證不會被奪走的資源。</p>
<h2 id="好處-1"><a href="#好處-1" class="headerlink" title="好處"></a>好處</h2><p>透過確保資源的獨佔，你可以避免前面提到的相關問題: 共同資源被占用導致的限制。</p>
<p>另外你的技術彈性又更高了一些，可以多做一些客制化的設定。</p>
<h2 id="壞處-1"><a href="#壞處-1" class="headerlink" title="壞處"></a>壞處</h2><p>前面提到的客制化設定見仁見智，因為通常這也代表需要維運的部分變多了。<br>於是也出現了一些服務是讓你去購買VPS，而他負責為你維運，像是cloudway。</p>
<p>另外因為還是共享著同一台物理主機，如果有其他在同一物理主機的網站遭到攻擊，導致你所在的主機遭受到系統級的損害，一樣會對你的網站造成傷害。</p>
<h2 id="專用主機-dedicated"><a href="#專用主機-dedicated" class="headerlink" title="專用主機 dedicated"></a>專用主機 dedicated</h2><ul>
<li>資源隔離度: 5</li>
<li>維運成本: 4</li>
<li>租借費用: 5</li>
<li>風險: 3</li>
<li>擴充性: 2</li>
</ul>
<p>顧名思義，你擁有一台物理主機的全部資源，基本上可以視為一台請服務商幫你維運硬體層面的主機了。</p>
<h3 id="好處-2"><a href="#好處-2" class="headerlink" title="好處"></a>好處</h3><p>前面提到的系統級風險再次降低。<br>通常可以取得root access，等同你擁有一台雲端主機，高客製化。</p>
<h3 id="壞處-2"><a href="#壞處-2" class="headerlink" title="壞處"></a>壞處</h3><p>很貴，且軟體維運幾乎也都仰賴用戶自行處理，維運成本也高，除非是公司有資安需要硬體級別的隔離，不然很難找到理由需要使用這樣子的服務。</p>
<p>另外擴充上也會在物理主機達到極限時出現明顯的瓶頸，需要進行硬體擴充，但因為相較於VPS，通常這也同樣是VPS的極限，所以我姑且給了他擴充性2的評分，比VPS略低，但也不是說他的上限就比VPS多多少就是了。</p>
<h2 id="雲-cloud"><a href="#雲-cloud" class="headerlink" title="雲 cloud"></a>雲 cloud</h2><ul>
<li>資源隔離度: 4</li>
<li>維運成本: 5</li>
<li>租借費用: 4</li>
<li>風險: 2</li>
<li>擴充性: 5</li>
</ul>
<p>Cloud hosting與前面的服務最大的差別在於你所購買的主機的部署方式並非在單個物理主機上，而是多個物理主機組成的虛擬化大型主機之上。</p>
<h3 id="好處-3"><a href="#好處-3" class="headerlink" title="好處"></a>好處</h3><p>可以想像你的服務器架設在超大型主機之上，於是你的服務所需資源的擴充性是相當大的，另外，租借成本通常來說，是根據你的用量來決定你的費用，這句話有時候很含糊，需要根據不同雲服務的服務商來計算費用。</p>
<p>另外關於風險，以AWS為例，資源分成由大至小分為Zone、AZ(Available Zone)，最佳實踐提到你可以至少在AZ部署多個server避免AZ級的損失，或甚至在不同Zone部署server避免Zone級的損失，當然費用也會往上，端看對於server停止服務的重要性來做判斷。</p>
<h3 id="壞處-3"><a href="#壞處-3" class="headerlink" title="壞處"></a>壞處</h3><p>相對於專用伺服器來說，資源隔離度下降，可以說是對安全的部分妥協。<br>另外的，與專用伺服器相同的是維運成本及server設置也都是相對高的。</p>
<p>另外他的費用來說其實也是不低的，若需要大量的資源，也會是每個月的巨額開支。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>了解Hosting的需求對於營運及提供技術建議帶來幫助，不過對於開發本身的幫助似乎就不是特別大了XD</p>
<p>以目前的經驗來看，若是商業需要，通常會至少選擇VPS作為託管，不過目前最流行應該是雲服務吧，不只提供了託管服務，還能夠透過他本身提供的其他雲服務做串接，像是靜態儲存、MQ、LB等，也減少了公司成長前期在維運上所需要花費的成本。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=AXVZYzw8geg&ab_channel=CraylorMade">Different between hosting</a><br><a href="https://www.top10.com/hosting/comparison?utm_source=google&kw=hosting&c=543733688286&t=search&p=&m=e&adpos=&dev=c&devmod=&mobval=0&network=g&campaignid=87845628&groupid=130392847161&targetid=kwd-10071570&interest=&physical=9040379&feedid=&a=2707&ts=hi&topic=&test=&clicktype=&gclid=CjwKCAjwpqCZBhAbEiwAa7pXebgXp-HemoHQ4DCEsFYZDSxx-9AdOYSja23VAuluwYXuaYmxh2dI8xoCKV0QAvD_BwE">Top 10 Hosting Service</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Hosting</tag>
      </tags>
  </entry>
  <entry>
    <title>電腦與外界的通訊方式-輸入/輸出(I/O)管理</title>
    <url>/code-blog/2022/09/27/OS_IO/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>許多Process的執行除了依賴CPU的運算及Memory的儲存，也依賴於其他設備，其中一部分專門用於接受使用者輸入及引導輸出的設備，被稱為I&#x2F;O設備，I&#x2F;O就是input及output的簡稱。</p>
<p>透過今天的內容，會稍微了解IO管理的設計，以及是透過什麼方式整合IO設備與CPU的溝通。</p>
<span id="more"></span>

<h2 id="IO管理的目標"><a href="#IO管理的目標" class="headerlink" title="IO管理的目標"></a>IO管理的目標</h2><ul>
<li>易用: 方便用戶使用</li>
<li>效率: 提高系統的併發工作能力</li>
<li>防錯: 增加設備的可靠及安全性</li>
</ul>
<h2 id="IO流程"><a href="#IO流程" class="headerlink" title="IO流程"></a>IO流程</h2><p>當系統發出指令需要執行IO功能時的流程是什麼呢?<br>我後來發現先大概看一下流程有個全觀的認識，後面了解起來會比較清楚。</p>
<p>以下資料來自<a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">Day-17 I&#x2F;O運作</a></p>
<table>
<thead>
<tr>
<th align="left">流程</th>
<th align="left">動作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User process發出I&#x2F;O request給OS</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">OS收到請求，可能暫停此process執行，並執行相對應的system calls。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">kernel的I&#x2F;O-subsystem會pass此請求給<strong>Device driver</strong>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Device driver依此請求設定對應的I&#x2F;O commands參數給<strong>Device Controller</strong>。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Device Controller啟動，監督I&#x2F;O-Device之I&#x2F;O運作進行。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">在此時，OS可能將CPU切給另外一個process執行。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">後續步驟根據<strong>IO控制方式</strong>。</td>
</tr>
</tbody></table>
<p>後面在介紹各個粗體的字詞後，我覺得對IO就會有個基本的認識了</p>
<h2 id="控制器Registers"><a href="#控制器Registers" class="headerlink" title="控制器Registers"></a>控制器Registers</h2><p>為了達到模組化及通用，一般會將IO區分為機械、電子兩個部分，機械通常是IO設備功能本體，而電子的部分會是用來連接系統的一塊主機板，稱作。</p>
<p><img src="https://i.imgur.com/UJtbyjM.png"><br>控制器包含三個重要的部分:</p>
<ul>
<li>Command Register: 存放CPU所呼叫的命令，讓CPU控制裝置。</li>
<li>Status Register: 存放CPU傳來的狀態資訊，讓CPU了解裝置狀態。</li>
<li>Data Register: 存放預備輸入或輸出的資料</li>
</ul>
<p>透過這三個控制器，操作系統簡化了開發不同設備的介面，有點像是操作系統預先設定好幾個標準介面要求IO設備去符合他們，好處是操作系統開發起來省力，並且可以提高設備的擴充性。</p>
<p>換個角度想就是，如果各家IO設備都有自己的API要求系統去處理，一是會累死系統開發人員，二是這樣就要等到系統支援才有辦法讓IO設備被系統使用。</p>
<h2 id="IO控制"><a href="#IO控制" class="headerlink" title="IO控制"></a>IO控制</h2><p>我自己是根據CPU介入的程度來分為以下4種:</p>
<ol>
<li>Process直接控制</li>
<li>Polling I&#x2F;O</li>
<li>Interrputed I&#x2F;O</li>
<li>DMA I&#x2F;O</li>
</ol>
<h3 id="Process直接控制"><a href="#Process直接控制" class="headerlink" title="Process直接控制"></a>Process直接控制</h3><p>直接由Process控制IO，優點是簡單易實現，缺點就是在IO傳輸時，CPU也被迫閒置等待。</p>
<h3 id="Polling-I-x2F-O"><a href="#Polling-I-x2F-O" class="headerlink" title="Polling I&#x2F;O"></a>Polling I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，在執行其他Process時會在完成指令週期時去輪詢polling裝置控制器確認是否完成。</p>
<p>因為CPU會有polling的成本，等於擠壓到執行Process的時間，適合Device執行速度的狀況，不然每次執行週期可能會需要輪詢過多device。</p>
<h3 id="Interrputed-I-x2F-O"><a href="#Interrputed-I-x2F-O" class="headerlink" title="Interrputed I&#x2F;O"></a>Interrputed I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，IO會在執行完畢後發出中斷指令，系統一樣在完成指令週期時做檢查，不管變成僅檢查中斷指令。</p>
<p>和Polling的差異在IO是否會發出中斷指令，CPU是否能夠處理，若支援這樣的機制，好處是CPU可以減少輪詢時間。</p>
<h3 id="DMA-I-x2F-O"><a href="#DMA-I-x2F-O" class="headerlink" title="DMA I&#x2F;O"></a>DMA I&#x2F;O</h3><p>透過建立一個直接的數據通路，以及授權讓一個DMA控制器對數據通路有存取的權力，使得CPU自由~~~</p>
<p>控制方式是，CPU在需要IO功能時授權DMA控制器，DMA會自行與IO溝通，並將所有工作完成，並且因為有一個直接的數據通道，DMA連數據傳輸也會處理，否則像Interrputed I&#x2F;O仍需要由CPU處理數據，並發出中斷命令給CPU，CPU需要參與的部分僅在IO功能的開始及結束。</p>
<p>優點是因為解放CPU，CPU的使用率大幅提升，但因為數據通道直接放在Memory，DMA會跟CPU搶Memory的使用權。</p>
<h2 id="硬體驅動程式"><a href="#硬體驅動程式" class="headerlink" title="硬體驅動程式"></a>硬體驅動程式</h2><p>除了controller，IO中另外一環重要的部分為device driver。</p>
<p>驅動程式負責理解系統對IO設備發出的指令，並轉化成IO硬體能理解的內容以執行工作。</p>
<p>根據以下這張圖，應該可以更清楚device driver跟device controller之間的關係。</p>
<p><img src="https://i.imgur.com/9kvjQpK.png"></p>
<p>剛好回頭對照前面IO功能在執行時的流程圖<br>system call被呼叫時，指令會透過kernel傳給device driver，在透過device driver將指令轉化成IO controller能理解的形式並傳送過去。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天就這樣啦~<br>明天會來看看關於Unix的標準-POSIX。</p>
<p>此文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/27/OS_IO/">部落格</a>，歡迎來逛逛喔~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/23.html">IO核心子系統</a><br><a href="https://www.omscs-notes.com/operating-systems/io-management/">IO Management</a><br><a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">IO運作</a><br><a href="https://www.quora.com/What-is-the-difference-between-device-driver-and-device-controllers">What-is-the-difference-between-device-driver-and-device-controllers</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>行程間通訊(Inter Process Communication)</title>
    <url>/code-blog/2022/09/25/OS_Inter_Process_Communication/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在系統內，Process或是Thread若需要與其他合作，就須要有溝通的方式，而溝通的原因包括資料分享需要、模組…等等，這些就被稱為行程間通訊。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>多個 process&#x2F;thread 內部要去溝通，都統稱叫做 IPC。</p>
<p>關於這點我曾經有點困惑，為什麼Thread之間的溝通也被稱為行程間通訊，我個人給他的解釋是，因為Thread本身也可以算是一個Process，只是跟其他同Process的Thread共享了部分記憶體空間。</p>
<p><del>不過說不定只是那時候的人取錯名字了?</del></p>
<h2 id="情境需要"><a href="#情境需要" class="headerlink" title="情境需要"></a>情境需要</h2><ul>
<li>資訊分享: node.js經過cluster產生的child process和main process需要溝通。</li>
<li>加速運算: Parallel</li>
<li>模組化</li>
<li>方便</li>
</ul>
<h2 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h2><ul>
<li>Shared Memory</li>
<li>Message Passing</li>
</ul>
<h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>共享記憶體以進行通訊，使用時不需要kernel。<br>不過若是兩個Process之間想要使用這個方式進行通訊會因為需要額外建立共享的memeory區塊而發出system call了。</p>
<h2 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h2><p>要實現這個通訊方式，必須包含</p>
<ul>
<li>溝通方法: send &amp; receive</li>
<li>溝通管道</li>
</ul>
<p>在有些資料中，雖然會將IPC分為更多類，不過我最後根據<a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ipc</a>這份資料，認為理解他們的方式應視為在討論Message Passing實踐時的相異之處。</p>
<p>其中包括討論:</p>
<ul>
<li>溝通管道如何被建立?<br>通常會討論是直接通訊Direct Communication或是間接通訊Indirect Communication。</li>
<li>一個管道是否可以與兩個以上的Process有關?</li>
<li>Process與Process之間可以有多少管道?</li>
<li>管道的容量有多少?可容納的訊息是固定還是可變的</li>
<li>管道是雙向還是單向的</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>看了資料後才發現其實IPC蠻靠近我們的<br>包括我們在shell裡面常用的pipe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find a | xargs grep &#x27;something&#x27;</span><br></pre></td></tr></table></figure>
<p>因為每個指令是一個process，前指令在將結果傳給後指令接收時使用的就是IPC。</p>
<p>另外瀏覽器請求server的通信也是。<br>不過IPC的細節實在太燒腦了，差點寫不完只好先停在這裡，若之後真的有機會再回頭來更新吧。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><!-- Tanenbaum & Bos 的Modern Operating Systems -->
<p><a href="https://hackmd.io/@YiZjennnnn/OS_Note/https%3A%2F%2Fhackmd.io%2F%40YiZjennnnn%2Fipc_interprocess_communication?type=book">IPC (Interprocess Communication)</a><br><a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ip</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix的標準-POSIX Basics</title>
    <url>/code-blog/2022/09/28/OS_POSIX_Basics/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>POSIX到底是什麼神秘的東西呢?老實說，在roadMap提到這個單字前，我是真的完全不知道他是什麼XD</p>
<p>其實他就是一種interface的標準，為了要讓作業系統之間的相容性提高，所以符合POSIX的應用程式都會有一個重要的特性是:</p>
<blockquote>
<p>應該要能與其他符合POSIX標準的作業系統相容</p>
</blockquote>
<p>於是今天會講到一些歷史，並提到關於POSIX具有移植性的一些原因。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>有人說他的全稱是Portable Operating System Interface，並且最後加上X代表Unix，不過官方似乎也沒針對名字的全稱給出解釋。<br>他是由IEEE制定的，並且符合此標準的應用程式應該具有如前言所說的特性。</p>
<p>也因為這樣，在Linux及類Unix系統上多數工具的行為會幾乎相同。<br>這邊為什麼會將Linux與Unix分開說呢?<br>因為Linux雖然是根據大部分的POSIX的標準實現的，但他是從頭開發的，所以根本上他並不與Unix有實質的關聯。</p>
<h2 id="歷史小故事"><a href="#歷史小故事" class="headerlink" title="歷史小故事"></a>歷史小故事</h2><p>Unix在1974年由貝爾實驗室對外發布，自此開始出現了多個版本，並也有Unix廠商試圖加上一些不相容的特性來讓系統與其他有所區隔。<br>而後，為了提高相容性及應用程式的可移植性，IEEE開始著手將Unix的開發標準化，後由Richard Stallman命名為”POSIX”。</p>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>這邊會談到為什麼遵循POSIX就代表具有可移植性。<br>基本上作業系統有兩種方式可以跟硬體溝通:</p>
<ol>
<li>system call</li>
<li>library function</li>
</ol>
<h3 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h3><p>由作業系統提供給Process的溝通介面，因為是由作業系統直接提供的，所以不同的作業系統他們所提供的system call介面可能不同。</p>
<h3 id="library-function"><a href="#library-function" class="headerlink" title="library function"></a>library function</h3><p>作業系統會提供另一種方式，將很多過程封裝成一些常用的函式，比如說，一個寫入的函式可能包含很多記憶體、硬碟的操作。<br>而所謂的符合POSIX其實就是指:</p>
<blockquote>
<p>這些函式需要輸入的參數、型別、回傳值等都符合POSIX要求的規範</p>
</blockquote>
<p>根據下圖你就能看到事實上其實一個function可能封裝了system call在其中，那這樣可以帶來什麼好處呢?<br><img src="https://i.imgur.com/FGJlGxm.png"></p>
<h3 id="使用library-function的好處"><a href="#使用library-function的好處" class="headerlink" title="使用library function的好處"></a>使用library function的好處</h3><ol>
<li>節省成本: 會這樣說的原因，需要回到前幾天談過的Kernel mode，當我們使用system call的時候其實會經過mode的轉換，這其實需要一些成本，我們可能會接著問，那library也會使用system call不會嗎?當然會，所以我們的角度會變成，盡可能在進入kernel mode時完成大部分的system call。</li>
<li>可移植: 回到原本談得移植性，當我們的Program是用符合POSIX標準的library與硬體溝通時，這代表這段程式碼可以被直接搬到一樣符合標準的系統，就算這些不同的library內部實現這些介面的方式不同，但這並不是開發人員在乎的事情。不過如果是直接使用system call呢?假如兩邊使用的參數或甚至名稱不同，那段就要經過檢查後重寫…</li>
</ol>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次的學習解答了為什麼我們在Linux或是其他類Unix的系統上所使用的script大部分都無法搬到windows上使用XD<br>而且通過資料，也看到windows從windows NT原本也期望符合POSIX，但最終放棄，他目前是改為面對開發人員，推出了wsl(Windows Subsystem for Linux)。</p>
<p>到今天為止總算在OS overview的部分告一段落了，後面幾天開始就是DB的一些overview囉!<br>明天見~~</p>
<p>本文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/28/OS_POSIX_Basics/">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>閒聊一下，我在寫這天的內容時，使用的正是wsl2，一般而言他還是蠻好用的，他讓我們可以在windows有好用的GUI基礎上，可以透過vscode或是terminal實現類似在linux上開發的感受，我個人覺得是可行的。<br>不過今天也出現問題，在複製照片想貼進md文件時出現了錯誤，看來是在同步剪貼簿時對於照片的轉換出現了問題…</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.baeldung.com/linux/posix">A Guide to POSIX</a><br><a href="https://unix.stackexchange.com/questions/11983/what-exactly-is-posix/220877#220877">What exactly is POSIX?</a><br><a href="https://zhuanlan.zhihu.com/p/392588996">posix是什麼都不知道，還好意思說你懂Linux</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>POSIX</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(上)-行程管理</title>
    <url>/code-blog/2022/09/23/OS_Process/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>行程是CPU分配資源的最小單位，以後還會聊到，甚至就連docker的container在run的時候就是一個process，很有趣吧，就來稍微認識一下~</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>一個較好記憶的說法會將行程解釋成運行中的應用程式(Application)，但有個比較貼切的說法是: 行程是一個正在運行中的應用程式實例。</p>
<p>實例隱含的意思是，由一個應用程式而建立的行程可以有多個，且雖然他們皆由同一個應用程式而來，他們可以具備不同狀態。</p>
<h2 id="行程架構"><a href="#行程架構" class="headerlink" title="行程架構"></a>行程架構</h2><p><img src="https://i.imgur.com/DlIreU0.png"></p>
<blockquote>
<p>引用自 <a href="https://www.guru99.com/process-management-pcb.html">https://www.guru99.com/process-management-pcb.html</a></p>
</blockquote>
<p>此圖大致代表Process在記憶體裡的結構，</p>
<ul>
<li>Stack: 暫時性資料，例如Function Parameters、Local variables</li>
<li>Heap: 執行程式碼所需要的動態工作區</li>
<li>Data: 儲存全域變數等</li>
<li>Text: 程式碼所在</li>
</ul>
<h2 id="行程生命週期"><a href="#行程生命週期" class="headerlink" title="行程生命週期"></a>行程生命週期</h2><p><img src="https://i.imgur.com/KgOOxn6.png"></p>
<blockquote>
<p>引用自 <a href="https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60">https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60</a></p>
</blockquote>
<p>共有五種狀態</p>
<table>
<thead>
<tr>
<th>狀態</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td>new創建</td>
<td align="left">初始狀態，分配及建立PCB以及其他資源，在完成上述工作後進入ready</td>
</tr>
<tr>
<td>ready就緒</td>
<td align="left">在隊列按照CPU Scheduling的演算法等待搶奪CPU以完成工作</td>
</tr>
<tr>
<td>running工作</td>
<td align="left">一旦搶奪到CPU，此狀態會被設置為工作中，並執行應用程式中的指令。在與ready狀態切換時，會作Context Switch</td>
</tr>
<tr>
<td>waiting等待</td>
<td align="left">如果因為事件或是IO速度的差異導致等待，就會停在此</td>
</tr>
<tr>
<td>terminated終止</td>
<td align="left">完成執行、被迫結束(比如在硬性即時系統)或者遇到錯誤時就會進入此狀態</td>
</tr>
</tbody></table>
<h2 id="Process-Control-Block-PCB"><a href="#Process-Control-Block-PCB" class="headerlink" title="Process Control Block, PCB"></a>Process Control Block, PCB</h2><p>記錄行程相關狀態資訊的資料區，每個行程都有自己的一個，並在Process創建時被建立。<br>其內容包含:</p>
<table>
<thead>
<tr>
<th align="left">項目</th>
<th align="left">內容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行程狀態process state</td>
<td align="left">流程生命週期的狀態</td>
</tr>
<tr>
<td align="left">程式計數器process counter</td>
<td align="left">紀錄下一個要執行的指令的位址</td>
</tr>
<tr>
<td align="left">CPU暫存器保存區</td>
<td align="left">不在running state時，CPU暫存器內容會被保存在此</td>
</tr>
<tr>
<td align="left">排班資訊</td>
<td align="left">例如行程優先等級(priority)等排班時所需要的參數</td>
</tr>
<tr>
<td align="left">記憶體資訊</td>
<td align="left">其內容根據記憶體系統的種類而定</td>
</tr>
<tr>
<td align="left">帳號資訊Accounting Information</td>
<td align="left">process所屬的使用者帳號(user id)、行程代號(process identification)、時間限制、已經使用掉的處理機時間、進入系統之實際時間</td>
</tr>
<tr>
<td align="left">IO狀態資訊</td>
<td align="left">如所配置之輸出入裝置串列、開啟(Opened)之檔案串列等資訊</td>
</tr>
</tbody></table>
<p>大部分資訊由參考資料2來的，並統整了其他資料的內容，所以更詳細可以看參考資料2。</p>
<h2 id="Process-Create"><a href="#Process-Create" class="headerlink" title="Process Create"></a>Process Create</h2><p>在OS內，Process可以建立child process，因此所有的排程可以組成一個樹狀結構。</p>
<p>如果你手邊有linux系統的話，可以使用 <code>pstree -aup</code> 看到在你的電腦裡的process的樹狀圖。</p>
<p><img src="https://i.imgur.com/Mjv8Wl7.png"></p>
<p>如上圖，甚至可以知道我是在zsh之下執行的這個指令XD</p>
<p>大部分的OS會支援兩種Process Create的方式</p>
<ul>
<li>Fork: 複製父行程的PCB到子PCB</li>
<li>Exec: 替換子行程的資料，初始化新的PCB資料</li>
</ul>
<p>所以建立新的Process就是兩者混用，先Fork一個子行程後，再Exec初始化子行程。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60">Operating System: Process and Process Management</a><br><a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html">PCB</a><br><a href="https://ithelp.ithome.com.tw/articles/10202866">程序(process)概念–上</a><br><a href="https://www.tutorialspoint.com/inter_process_communication/inter_process_communication_process_creation_termination.htm">Process Creation</a><br><a href="https://ithelp.ithome.com.tw/articles/10276152?sc=rss.iron">Process</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
      </tags>
  </entry>
  <entry>
    <title>作業系統(Operating System/OS) Overview(上)</title>
    <url>/code-blog/2022/09/21/OS_System-Concept_Overview/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從今天開始進入OS一般知識的範圍，透過了解我們正運行中的程式(Process)在OS如何運作的過程及相關知識，包含I&#x2F;O, Thread, Memory…等，可以進一步優化程式。</p>
<p>稍微具體舉個例子來說，以node.js來說，作為單執行緒(thread)的執行環境，若一下出現大量的使用者情求時會是什麼狀況呢，如果已經在工作的人，你可以想像辦公室明明有很多人，但電話只跑到你這裡，你頂多叫他們做點事情幫忙，但最終還是你一個人處理所有的電話…情何以堪XD</p>
<p>為了解決這個問題，因此有了pm2套件、原生的cluster及worker threads，他們各自有不同的問題解決邏輯，或許通過這段時間的鑽研我們可以稍微探討這些差異。</p>
<p>我個人是蠻期待這部分的學習，那，就開始今天的OS overview吧。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><blockquote>
<p>一組主管並控制電腦操作、運用和執行硬體、軟體資源和提供公共服務來組織使用者互動的相互關聯的系統軟體程式。 – <a href="https://zh.wikipedia.org/zh-tw/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">維基百科</a></p>
</blockquote>
<p>這邊我用我的方式來理解作業系統是: 提供易於操作的介面，讓程式開發者&#x2F;使用者可以用更簡單直覺的方式操作硬體。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>於是，作業系統的用途包含但可能不限於以下:</p>
<ol>
<li>控制及管理硬體資源</li>
<li>提供使用者介面</li>
<li>程式的錯誤預防</li>
</ol>
<p>根據需求情境及使用者對象，其考量而產生的作業系統型態可能會完全不一樣，比如說，家用個人電腦的目標是讓使用者更方便的使用系統，所以可能會更在意GUI(圖形化介面)的方便性；而伺服器的目標是資源的隔離性及使用率最佳化，可能面向的對象多是開發者，其介面可能僅會使用CLI(文字命令介面)。</p>
<h2 id="作業系統與硬體的互動"><a href="#作業系統與硬體的互動" class="headerlink" title="作業系統與硬體的互動"></a>作業系統與硬體的互動</h2><p>一般來說會分成使用者(User)及應用程式(Program)透過OS與硬體互動，使用者通過OS的命令直譯器(Command Interpreter)與硬體互動，而當使用者在操作應用程式時，應用程式會對OS做系統呼叫(System Call)，進而與硬體層溝通，完成使用者指定的操作。</p>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><p>在進入後面一般系統種類介紹前，也想先對幾個名詞作概要的解釋，會對於後面的內容有比較好的理解。</p>
<h3 id="CPU-Scheduling-Short-term-Scheduling"><a href="#CPU-Scheduling-Short-term-Scheduling" class="headerlink" title="CPU Scheduling(Short-term Scheduling)"></a>CPU Scheduling(Short-term Scheduling)</h3><p>最早期的系統其實是單純的順序，意思是指，CPU會按照程式的執行順序，依序把工作完成，其中常有造成CPU珍貴的運算資源被閒置的狀況，像是程式設計錯誤，或是因為硬體的速度不一，導致CPU等待其他工作完成…等等。</p>
<p>因此為了得到最大的CPU使用率，會藉由適當的排班演算法，先CPU處理該process(CPU Burst)，接著做I&#x2F;O資料的傳送(I&#x2F;O Burst)，process會在這兩個狀態一直循環，最後在工作完成後呼叫一個終止Process的System Call作為結束。</p>
<p>這可以說是後面的系統類別在設計時的核心之一，目標式在確保CPU使用率的狀況下，作出最符合當前系統情境的需求的決策。</p>
<h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>CPU使用權轉移時，需要儲存舊的Process資訊，載入新Process資訊，這個工作就稱之為Context Switching。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>內容遠比我想得來的多了，不得已之好分成兩天完成來完成了XD<br>明天會開始介紹作業系統的種類。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10232695">Node Cluster 讓你的 Thread 不再孤軍奮戰</a><br><a href="https://stackoverflow.com/questions/56656498/how-do-cluster-and-worker-threads-work-in-node-js">Different between cluster and worker thread</a><br><a href="https://www.youtube.com/watch?v=Cl0uql06KK0&ab_channel=%E3%80%90%E6%9D%B0%E5%93%A5%E6%95%B8%E4%BD%8D%E6%95%99%E5%AE%A4%E3%80%91">作業系統簡介</a><br><a href="https://ithelp.ithome.com.tw/articles/10203990">CPU Scheduling</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>OS</tag>
        <tag>CPU Scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>作業系統(Operating System/OS) Overview(下)</title>
    <url>/code-blog/2022/09/22/OS_System_Classification_Overview/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介紹各個系統作業類別，透過了解系解的分類及概要的內容，會對於作業系統有更進一步的認識的~<br>那就開始吧!</p>
<span id="more"></span>

<h2 id="作業系統類別"><a href="#作業系統類別" class="headerlink" title="作業系統類別"></a>作業系統類別</h2><ol>
<li>多元程式規劃 Multiprogramming System</li>
<li>分時系統 Time Sharing System</li>
<li>分散式系統 Distributed System</li>
<li>即時系統 Real Time System</li>
<li>集成&#x2F;叢集式系統 Clustered System</li>
</ol>
<h3 id="多元程式規劃Multiprogramming-System"><a href="#多元程式規劃Multiprogramming-System" class="headerlink" title="多元程式規劃Multiprogramming System"></a>多元程式規劃Multiprogramming System</h3><ul>
<li>定義: 存在多組Process同一段時間內同時執行</li>
<li>目的: 避免CPU閒置，提升使用率</li>
</ul>
<p>系統內存在許多等待執行的Process，而透過CPU Scheduling讓CPU可以在不同Process中切換(Context Switch)，讓CPU保持忙碌減少閒置。</p>
<p>為什麼需要切換，因為為了完成軟體需執行的動作，可能需要依賴除了CPU以外的硬體，若CPU的運算過程出現需等待其他硬體先完成後才能繼續執行的事件，就會造成閒置(idle)。</p>
<p>一般而言，Multiprogramming degree(註1)越高，CPU使用率越高，意思是指說越不會出現因為等待其他軟體操做其他硬體工作而造成閒置，除非遇到輾轉現象(Thrashing(註2))。</p>
<h3 id="分時系統-Time-Sharing-System"><a href="#分時系統-Time-Sharing-System" class="headerlink" title="分時系統 Time Sharing System"></a>分時系統 Time Sharing System</h3><ul>
<li>定義: 屬於Multiprogramming System其中之一，透過資源共享技術，使User認為有各自專屬的系統存在。</li>
<li>技術:<ul>
<li>CPU: CPU Scheduling，採用Round-Robin(註3)</li>
<li>Memory: 共享Memory Space</li>
<li>I&#x2F;O device: Spooling(註4)</li>
</ul>
</li>
</ul>
<p>此系統容許多人同時使用，並對個別的請求盡可能快的產生反應，如果這個輪流使用資源的速度夠快，會看起來像是每個人都在同時與該系統互動，故也會被稱為交談式系統，像是遊戲。</p>
<h3 id="分散式系統-Distributed-System"><a href="#分散式系統-Distributed-System" class="headerlink" title="分散式系統 Distributed System"></a>分散式系統 Distributed System</h3><p>可分成兩類: </p>
<ol>
<li>緊密耦合Tightly Coupled: Multiprocessor, Parallel</li>
<li>鬆散耦合Loosely Coupled: Distributed</li>
</ol>
<h4 id="緊密耦合-Multiprocessor-x2F-Parallel"><a href="#緊密耦合-Multiprocessor-x2F-Parallel" class="headerlink" title="緊密耦合 Multiprocessor&#x2F;Parallel"></a>緊密耦合 Multiprocessor&#x2F;Parallel</h4><ul>
<li>定義: 同一機器具有2顆以上的CPU或Processor存在，且同時符合以下特性<ul>
<li>共享記憶體、I&#x2F;O設備、Bus(註5)</li>
<li>受同一個Clock及OS的控制</li>
<li>CPUs之間的資料交換，採Share Memory(註6)</li>
</ul>
</li>
</ul>
<p>支援Parallel Computing，可將Processes或單一Process上subtasks指派到不同CPU，平行直行。</p>
<ul>
<li><p>優點:</p>
<ul>
<li>產能: 可同時執行多工作，或單一工作拆分部分。</li>
<li>符合效益: 共用記憶體、I&#x2F;O、BUS，在完成MultiProcessor的演算法之後，就不用用多台電腦叢集，但閒置了必配置的上述資源。</li>
<li>可靠度: 單一Processor掛掉之後可以保證工作繼續維持。</li>
</ul>
</li>
<li><p>問題:<br>n個CPU不等同於n倍效能，會因為前者提到在多工的通訊或共用的資源的競爭導致效能的消耗。</p>
</li>
</ul>
<p>可以想像看看，公司的團隊人數增加兩倍時，就會有兩倍的產能出現嗎…</p>
<ul>
<li>類型細分:<ul>
<li>對稱式多元處理Symmetric Multiprocessing, SMP:<br>每一個Processor功能相同，可靠度較高，單一Processor壞掉會將未完成工作轉移到其他Processor身上，強調負載平衡，想像起來有點像並聯的感覺。</li>
<li>非對稱式多元處理Asymmetric Multiprocessing, ASMP:<br>又稱做Master&#x2F;Slave架構，通常有一個單位(個&#x2F;群)的Master Processor，負責控制、分配Process到其他Processor去運作，效能相對SMP好，但可靠度較差。</li>
</ul>
</li>
</ul>
<h4 id="鬆散耦合-Distributed"><a href="#鬆散耦合-Distributed" class="headerlink" title="鬆散耦合 Distributed"></a>鬆散耦合 Distributed</h4><ul>
<li>定義: 相對於緊密耦合，可以視為多台電腦的叢集。</li>
</ul>
<p>現代網路的運作模式可以視為是這樣的鬆散耦合，通過一些經過標準化的協定傳遞訊息做溝通。</p>
<ul>
<li>類型細分:<ul>
<li>網路作業系統(NOS):<br>在知道其他端點的資訊下，透過網路協定進行訊息溝通。</li>
<li>分散式作業系統(DOS):<br>讓使用者已像是在存取自己資源的方式使用遠方端點資源，資料以及運算全在OS控制之下，使用者無法得知是在遠端或是本端得到資源。</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/zProh6x.png"></p>
<blockquote>
<p>圖片來自碁峯-作業系統理論與實務–第二版(雙色印刷)15-3</p>
</blockquote>
<h3 id="即時系統-Real-Time-System"><a href="#即時系統-Real-Time-System" class="headerlink" title="即時系統 Real Time System"></a>即時系統 Real Time System</h3><ul>
<li>定義: 嚴謹的定義的時間限制，Processor在處理工作時必須在時間內完成，若否即失效。</li>
</ul>
<p>可分成兩類</p>
<ol>
<li>硬性即時系統</li>
<li>軟性即時系統</li>
</ol>
<h4 id="硬性即時系統"><a href="#硬性即時系統" class="headerlink" title="硬性即時系統"></a>硬性即時系統</h4><p>狹義化的即時系統定義，並相對於柔性即時系統。</p>
<ul>
<li>注意限制: 除了OS運作的時間以外，也要考慮系統內的delay(如傳輸、硬體運算等)必須須小於情境所需要的Time Constraint。</li>
<li>OS特性: OS的功能少甚至沒有，以減少干預，強調即時，限制延遲。</li>
<li>使用需求可以想像這個系統是需要在特定時間限制需求的環境下使用的。</li>
</ul>
<h4 id="軟性即時系統"><a href="#軟性即時系統" class="headerlink" title="軟性即時系統"></a>軟性即時系統</h4><p>確保高優先權Process會先於低優先權被完成，且高優先權Process的優先權要維持到工作完成，對比硬性即時系統來看，此系統僅能保證高優先權最先，但不會限定什麼時間完成。</p>
<ul>
<li>注意限制: OS造成的延遲要盡可能縮短，避免優先權反轉(註7)問題。</li>
<li>OS特性: 支援Priority優先權演算法，且優先權不能被Aging(註8)。</li>
</ul>
<h3 id="集成-x2F-叢集式系統-Clustered-System"><a href="#集成-x2F-叢集式系統-Clustered-System" class="headerlink" title="集成&#x2F;叢集式系統 Clustered System"></a>集成&#x2F;叢集式系統 Clustered System</h3><ul>
<li>定義: 其定義有點類似分散式系統: 集合多個CPU完成工作並共享儲存裝置稱為一個clustered，且又透過連線緊密連結。</li>
</ul>
<p>差異的話，相對於Tightly coupled，他不是多個CPU共用相同資源；而相對於loosely coupled，他也不是多個<strong>單獨系統</strong>作訊息溝通。</p>
<p>硬要想像跟理解的話，有點像是多個Tightly coupled系統作loosely coupled，不過每個Tightly coupled系統僅共享儲存裝置這樣。</p>
<p>不過回頭來看，我們要說Tightly coupled系統也是一種Clustered System，應該也是符合定義的吧。</p>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><h3 id="註1-Multiprogramming-degree"><a href="#註1-Multiprogramming-degree" class="headerlink" title="註1- Multiprogramming degree"></a>註1- Multiprogramming degree</h3><p>系統內等待執行的Process數量</p>
<h3 id="註2-Thrashing"><a href="#註2-Thrashing" class="headerlink" title="註2- Thrashing"></a>註2- Thrashing</h3><p>因為Context switch需要記憶體或虛擬記憶體作為資訊存放的地方，於是，當Multingprogramming degreee超過一定程度時，會讓所有Process忙於資訊在記憶體及虛擬記憶體(disk)轉換之中，CPU為了等待完成反而造成閒置。</p>
<h3 id="註3-Round-Robin"><a href="#註3-Round-Robin" class="headerlink" title="註3- Round-Robin"></a>註3- Round-Robin</h3><p>每個Process有固定的配額時間，配額的時間沒完成目前的工作，Process會被迫放棄並讓出CPU的使用。</p>
<h3 id="註4-Spooling"><a href="#註4-Spooling" class="headerlink" title="註4- Spooling"></a>註4- Spooling</h3><p>為了因應速度不相同的裝置，在兩者之間設置緩衝區(Buffering)，以減少兩者速度傳輸造成的閒置或是順序錯誤。</p>
<p>常見的舉例像是: 印表機處理多個裝置的影印工作不會錯置順序。</p>
<h3 id="註5-匯流排Bus"><a href="#註5-匯流排Bus" class="headerlink" title="註5- 匯流排Bus"></a>註5- 匯流排Bus</h3><p>指的是電腦組件之間交換資料的方式，我的理解就是主機板上連接著組件間的線路。</p>
<h3 id="註6-Share-Memory"><a href="#註6-Share-Memory" class="headerlink" title="註6- Share Memory"></a>註6- Share Memory</h3><p>允許兩個不相關的Process進入讀取、寫入的邏輯記憶體。</p>
<h3 id="註7-Priority-Inversion優先權反轉"><a href="#註7-Priority-Inversion優先權反轉" class="headerlink" title="註7- Priority Inversion優先權反轉"></a>註7- Priority Inversion優先權反轉</h3><p>高優先權Process在特定情況下，遭到低優先權阻擋而無法完成工作。</p>
<p>特定情況像是，雖然高優先權拿到了CPU的使用權，但低優先權霸佔了高優先權完成工作時需要的資源，造成CPU idle。</p>
<h3 id="註8-aging"><a href="#註8-aging" class="headerlink" title="註8-aging"></a>註8-aging</h3><p>系統根據特定規則，將系統內很長時間未完成工作的process逐步提高其 Priority的技術。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在了解了這些不同的作業系統類別之後，我發現這些作業系統的設計其實都是跟著實務上使用的需求而專門誕生的，只是後續才被整理出這些類別才是。</p>
<p>在大概了解完OS之後，其實還是有很多大大小小的內容可以在深入了解一些，那接著就是在介紹時常常提到的行程Process囉!</p>
<p>此篇文章同步發表於<a href="https://medium.com/on-my-way-coding/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-operating-system-os-overview-%E4%B8%8B-37670e4c368a">部落格</a>，歡迎逛逛~</p>
<p>如果沒有前面那是正常的，因為我從今天才決定要放部落格的XD</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=tA4KiYrFdAM&ab_channel=%E3%80%90%E6%9D%B0%E5%93%A5%E6%95%B8%E4%BD%8D%E6%95%99%E5%AE%A4%E3%80%91">作業系統簡介</a><br><a href="https://ithelp.ithome.com.tw/articles/10203950">即時作業系統</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">Shared Memory</a><br><a href="https://zh.m.wikipedia.org/zh-tw/%E6%80%BB%E7%BA%BF">匯流排</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(中)-執行緒管理</title>
    <url>/code-blog/2022/09/23/OS_Thread/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天會討論執行緒Thread，是一個我覺得很容易跟行程Process混淆的概念，為了學習跟整理這個概念，我們可以踩在前人的肩膀上前進XD</p>
<p>透過一張別人整理出來的Process、Thread比較圖，我們來問問一些「為什麼?」。<br>而透過回答經過整理的問題，可以看到兩者的差別及是什麼造成這些差別。</p>
<p>而最後我相信通過探究這些差異的過程，不只可以幫助理解Thread，也同時可以回頭幫助了解Process~</p>
<span id="more"></span>

<h2 id="執行緒Thread"><a href="#執行緒Thread" class="headerlink" title="執行緒Thread"></a>執行緒Thread</h2><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="left">Process</th>
<th align="left">Thread</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定義</td>
<td align="left">在執行中的程式</td>
<td align="left">行程的一部分</td>
</tr>
<tr>
<td align="left">輕量</td>
<td align="left">不輕量</td>
<td align="left">輕量</td>
</tr>
<tr>
<td align="left">終止時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">建立時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">溝通</td>
<td align="left">行程間的溝通較費力且相對Thread來說更久</td>
<td align="left">溝通容易且相對較短</td>
</tr>
<tr>
<td align="left">上下文交換</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">資源 (CPU時間)</td>
<td align="left">消耗較多資源</td>
<td align="left">較少</td>
</tr>
<tr>
<td align="left">記憶體</td>
<td align="left">幾乎隔離</td>
<td align="left">有共享的記憶體位置</td>
</tr>
<tr>
<td align="left">資料共用</td>
<td align="left">不共用資料</td>
<td align="left">共享資料</td>
</tr>
<tr>
<td align="left">from <a href="https://www.guru99.com/difference-between-process-and-thread.html">Process vs Thread – Difference Between Them</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="為什麼說Thread是Process的一部分"><a href="#為什麼說Thread是Process的一部分" class="headerlink" title="為什麼說Thread是Process的一部分?"></a>為什麼說Thread是Process的一部分?</h3><p>我們可以用三種角度來看這個定義，看能不能釐清他們!</p>
<h4 id="角度1-工廠藍圖想像"><a href="#角度1-工廠藍圖想像" class="headerlink" title="角度1: 工廠藍圖想像"></a>角度1: 工廠藍圖想像</h4><p>我們先用比較淺顯的想像開頭:</p>
<blockquote>
<p>想像我們按照「藍圖」建立「工廠」，「工廠」裡面會聘請「工人」來完成工作。</p>
</blockquote>
<p>上面提到的藍圖、工廠、工人分別就是Program、Process、Thread。<br>所以實際上完成功作的是作為工人的Thread。</p>
<p>但這邊我在看的時候產生一個困惑，我們在操作系統簡介不是曾說: </p>
<blockquote>
<p>Process會根據CPU scheduling機制搶占CPU資源</p>
</blockquote>
<p>這樣到底是Process還是Thread完成工作呢?</p>
<p>其實這句話依舊是正確的，只是說的還不夠多，要了解這點，我們需要先知到Thread到底是什麼又存在哪裡。</p>
<p>透過一張圖的幫忙會更容易理解了。</p>
<h4 id="角度2-單執行緒行程-vs-多執行緒行程"><a href="#角度2-單執行緒行程-vs-多執行緒行程" class="headerlink" title="角度2: 單執行緒行程 vs 多執行緒行程"></a>角度2: 單執行緒行程 vs 多執行緒行程</h4><p><img src="https://i.imgur.com/Np4e2XK.png"></p>
<blockquote>
<p>from <a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">程序、行程(process)</a></p>
</blockquote>
<p>這是一張單執行緒Process與多執行緒Process的比較圖。<br>我們回到表格中的定義:</p>
<blockquote>
<p>執行緒是行程的一部分</p>
</blockquote>
<p>這樣是不是就很明顯地看到這個定義了呢?<br>執行緒確實是行程的一部分，於是昨天提到的行程結構，其實就是一個單執行緒行程。</p>
<p>確切來說，執行緒的結構包含獨立的: stack、register、counter<br>並且與其他Thread共用code, date(共用變數區), files。</p>
<p>正因為每個Thread有自己的Register、Counter、Stack，所以他們可以自己決定執行哪段程式，也就是說:</p>
<blockquote>
<p>每段執行緒可以執行各自片段的程式碼以完成Process需要完成的工作</p>
</blockquote>
<h4 id="角度3-概念總結"><a href="#角度3-概念總結" class="headerlink" title="角度3: 概念總結"></a>角度3: 概念總結</h4><p>最後來整理一下，並帶到最後一個對Thread及Process之間差異的描述:</p>
<blockquote>
<p>Process是OS分配資源之對象單位，而Thread才是OS分配CPU時間之對象單位<br>  – <a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a></p>
</blockquote>
<h3 id="為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少"><a href="#為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少" class="headerlink" title="為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?"></a>為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?</h3><!-- 建立Thread就像在固定好，且較小的範圍建立資料 -->
<p>Process建立流程包括:</p>
<ol>
<li>向系統註冊，讓系統紀錄執行清單，並標上PID。</li>
<li>分配適當的資源，包含CPU使用權及獨立的資料儲存空間。</li>
</ol>
<p>這個過程會申請空白PCB並初始化資料並填入PCB。</p>
<p>而因為Thread共用了大部分Process的狀態(這邊幫助你回憶一下，Thread是Process的一部分XD)，所以可以減少建立及管理的開銷。<br>另外一部分牽涉到Context Switch的成本，因為行程在進行Context Switch時，需要保存整個Process的狀態資訊，包括Counter、CPU registers、PCB，在處理這個過程花費的CPU相對Thread較多，因為Thread僅需要保存他自己的CPU register而已。</p>
<p>用工廠的說法來描述這些成本的差異好了。<br>建一個工廠需要選地址、找監督特別記錄所有工廠的資料、建立所有流程；而多請一個員工，因為原本的工廠裡面的流程都還在，所以大部分要做的事情都可以被省略。</p>
<h3 id="為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行"><a href="#為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行" class="headerlink" title="為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?"></a>為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?</h3><p>一個相同行程裡面多個Thread在被建立時，都可以共用同一個Process裡面的區塊的資料，這個區塊就是Heap，可以把這個區塊理解成像是全域變數的存在。</p>
<p>而不同Process在被建立時，他們彼此之間就會被分配不同的記憶體位置，因為沒有共用記憶體，所以Process之間如果需要溝通就要靠其他方法，一般統稱這些方法為Inter-process communication(IPC)，而這個過程相對不易，但也確保了行程內的資料不易被汙染。</p>
<p>盡可能保持Process之間的獨立性是有它的意義的，就好像我們現在可以毫無猶豫的ctrl + alt + delete直接強制關閉行程卻不用擔心造成其他行程的影響，因為他們之間互不依賴。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過了解Thread，我們進一步釐清了Thread這個概念被建立想要去處理的問題是快速的多工，並提高了資源(CPU、Memory…)的使用率。<br>於是接下來會進到下集，我們要談的Concurrency，可以說Thread幾乎是為此而生XD至於為什麼這麼說，下一篇也會試圖解釋這件事情!<br>那就明天見囉~</p>
<p>本文章同步分享於<a href="">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>其實原本是要將內容分成上下兩個部分，但Process、Thread、Concurrency這三個主題實在太息息相關，可以講的東西又太多了。<br>不知不覺，篇幅就大到一天要讀完太過難受，為了閱讀體驗<del>以及我的鐵人賽挑戰</del>，所以最終才分成三篇。<br>另外，若有人看不懂本篇的內容的話，可以回頭從<a href="https://ithelp.ithome.com.tw/articles/10295580">OS overview</a>開始看起喔。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">行程及執行緒</a><br><a href="https://www.quora.com/Why-are-threads-considered-cheap">Why Thread Considered Cheap</a><br><a href="https://stackoverflow.com/questions/1897993/what-is-the-difference-between-concurrent-programming-and-parallel-programming">What is the difference between concurrent programming and parallel programming?</a><br><a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a><br><a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a><br><a href="https://hackmd.io/@sysprog/linux-process">Linux 核心設計: 不僅是個執行單元的 Process</a><br><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.geeksforgeeks.org/threads-and-its-types-in-operating-system/">Threads and its types in Operating System</a><br><a href="https://medium.com/@yovan/os-process-thread-user-kernel-%E7%AD%86%E8%A8%98-aa6e04d35002">OS Process &amp; Thread (user&#x2F;kernel) 筆記</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(下)-並發(concurrency)</title>
    <url>/code-blog/2022/09/24/OS_concurrency/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>並發Concurrency也是一個常在開發中聽到的名詞，他跟並行Parallel有什麼差別呢?他能夠給系統帶來什麼好處?又有什麼風險需要注意?我們常聽到js是個單執行緒的語言，這又是什麼意思?node.js是單執行緒嗎?</p>
<p>這就是今天會希望解答的問題，那就開始吧~</p>
<span id="more"></span>

<h2 id="Concurrency-vs-Parallel"><a href="#Concurrency-vs-Parallel" class="headerlink" title="Concurrency vs Parallel"></a>Concurrency vs Parallel</h2><p>雖然我們今天的主題談的是Concurrency(並發)，但通常會與Parallel(並行)作個比較。</p>
<p><img src="https://i.imgur.com/kPV2fk8.png"></p>
<p>這是我在找資料學習時最喜歡的一張圖，我覺得他比較正確的視覺化Concurrency及Parallel的定義及關係。<br>邊對照圖片，我們邊看這兩者的定義</p>
<ul>
<li>Concurrency: 多件事可以在一段時間內同時進行</li>
<li>Parallel: 有多件事可以在一個時間點同時進行</li>
</ul>
<p>看起來很像對吧，雖然兩邊都是講同時，但他們對於時間的粒度不太相同，我覺得用排除法去想這件事情比較容易:</p>
<blockquote>
<p>當我們在判斷現在是什麼狀況時，先看<strong>某一個瞬間</strong>可不可以有多個任務同時進行，有的話那就是Parallel；若否，再看<strong>一段時間軸</strong>內可不可以有多件事情同時進行，那就是Concurrency。</p>
</blockquote>
<p>這也是圖片說的，如果一個系統內可以作到Parallel，那他必定也是Concurrency。<br>另外從圖裡面的CPU的表示也能看到，一般而言(註1)一個CPU同時只能被分配給一個thread，在這個狀況下，只有多CPU的狀況才能出現Parallel，這也是為什麼今天我們只先討論Concurrency。</p>
<p>註1: 除非今天CPU支援Hyper-threading(超執行緒)。</p>
<h2 id="Multi-process-Multi-thread-都擠"><a href="#Multi-process-Multi-thread-都擠" class="headerlink" title="Multi process, Multi thread 都擠?"></a>Multi process, Multi thread 都擠?</h2><p>根據Concurrency的定義其實我們可以有兩種Concurrency的方法，一個是多執行緒，一個是多行程，他們都會有多個執行緒讓CPU得以分配時間在他們身上。<br>不過如果你有從昨天一路看下來，就會發現，多行程是一個非常大的成本花費，我們也可以有一個結論，基本上除非你希望資源被隔離得很徹底，不然在Concurrency上，我們應該盡可能使用多執行緒去作Concurrency。</p>
<p>這邊就有一個例子，大部分的web server在接受到新的request時，是不用等待前面的請求結束對吧?一般而言，都是建立thread去處理請求而非process，然後結束時就立刻把thread terminate。</p>
<p>再來我們試著用反例想想，如果我們是以建立process的方式來處理多請求同時出現會發生什麼狀況?<br>第一可能會在建立process就花一點時間，當處理完請求後，又會遇到一個難題是要不要把Process砍掉，如果砍掉下次建立又要花時間，但是不砍掉，他會霸佔部分記憶體資源無法使用，如果有某個請求需要超過原本的記憶體大小，就可能造成memory leak。</p>
<p>當然也有使用多Process的例子，根據這篇資料:</p>
<blockquote>
<p>Google had to decide how to handle that separation of tasks. They chose to run each browser window in Chrome as a separate process rather than a thread or many threads, as is common with other browsers.<br>– <a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/">What’s the Diff: Programs, Processes, and Threads</a></p>
</blockquote>
<p>Google決定選擇使用多進程的原因可以在內文詳看，但他們認為這可以減少最終對於記憶體的使用。</p>
<h2 id="並發的好處"><a href="#並發的好處" class="headerlink" title="並發的好處"></a>並發的好處</h2><p>於是我們可以來整理一下，使用並發的好處包括有什麼呢?(無論Process或是Thread)</p>
<ul>
<li>性能提升: 能夠做到並發的系統，多個Process在運行時的總時間 &lt;&#x3D;(註1) 順序運行Process的總時間。</li>
<li>多程式應付可能: 透過CPU scheduling可以讓系統體感像是多個程式在同時進行一樣。</li>
<li>資源利用: 減少CPU閒置。</li>
</ul>
<p>額外補充，若使用多Thread相對多Process處理並發的好處有什麼呢: </p>
<ul>
<li>Parallel的可能性: 我們前面談的是單核心處理多Thread的狀況，但如果假使是在一個多Processor(多核心、單核心超執行緒…等等)的架構中，經過規劃的多執行緒程式可以在一個時間點同時進行多個Thread的工作，讓並行得以發生。</li>
<li>專業化: 我們可以把工作分門別類產生多個Thread去處理特定工作，甚至可以管理Thread，像是可以去管理Thread的優先層級。</li>
<li>高效: 前面也提到過，Thread相對Process，建立成本低、資料分享容易、資源利用度高，這都是相對多Process高效的原因。</li>
</ul>
<p>註1: 假如這邊範例中的多個process都僅需要CPU運算，因為沒有速率差異導致的閒置問題，那執行併發跟順序執行，總時間都會相同。</p>
<h2 id="並發的風險"><a href="#並發的風險" class="headerlink" title="並發的風險"></a>並發的風險</h2><p>除了好處，事實上多執行緒有許多因為共用資源等特性產生的風險需要在開發時顧慮:</p>
<ul>
<li><p>競爭race condition:<br>正因為共用資料，當出現I&#x2F;O或其他不可控的時間或順序事情時，有可能導致順序依賴的錯誤。<br>例如: 有個變數x &#x3D; 3，兩個共用資源的程式可能有兩個操作 x &#x3D; x + 2, x &#x3D; x + 3，結果意外出現5或6，但原本預期最後結果要是8，想像這如果是你的存款XD<br>而且這樣的錯誤又相當難以追蹤，因為並沒有相關錯誤訊息~</p>
</li>
<li><p>死鎖dead lock:<br>當一個Process在等待其他Process釋放手上的資源時。<br>比如P1需要P0手上的disk資源，但此時P0因為讓出CPU給P1，以至於兩者都無法完成工作。</p>
</li>
<li><p>飢餓starvation:<br>當一個Process因為一直被剝奪完成工作需要的資源。<br>比如因為優先權演算法，P0因為其他優先權更高的Process不斷出現而遲遲拿不到CPU運算。</p>
</li>
</ul>
<p>他們最大的差異，死鎖是除非有額外的機制處理，不然兩者是永遠無法完成工作的；而飢餓則是有機會完成工作，只是不知道什麼時候才會完成。</p>
<h2 id="User-Thread-vs-Kernel-Thread"><a href="#User-Thread-vs-Kernel-Thread" class="headerlink" title="User Thread vs Kernel Thread"></a>User Thread vs Kernel Thread</h2><p>並發的內容看起來結束了，但看到這邊還有一長段你就會知道還沒有XD<br>事實上，大部分的操作系統為了介入一般應用程式及管理他們，他們會使用一個叫做Kernel的程式。<br>而這個Kernel也影響了多執行緒行程如何與操作系統工作，由此出現了user thread及kernel thread這兩個概念。<br>我覺得有個更好稱呼他們的方式是user-level thread及kernel-level thread。</p>
<p>於是在比較他們之前我們需要先了解什麼是Kernel及mode。</p>
<h3 id="Kernel-是什麼"><a href="#Kernel-是什麼" class="headerlink" title="Kernel 是什麼?"></a>Kernel 是什麼?</h3><p>所以究竟Kernel是什麼，他產生thread的原因是什麼呢?</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8f/Kernel_Layout.svg"><br>他其實也是一個系統中的一個具有足夠優先權限的Process，負責處理其他Process與硬體之間的溝通。<br>需要他的原因在於與硬體溝通是相當複雜的，他提供了介面讓硬體操作被抽象化。</p>
<blockquote>
<p>嚴格地說，核心並不是電腦系統中必要的組成部分。有些程式可以直接地被調入電腦中執行；這樣的設計，說明了設計者不希望提供任何硬體抽象和作業系統的支援<br>– <a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">維基百科</a></p>
</blockquote>
<p>Kernel會在其他任何Process被載入，讓操作系統得以介入每個Process，這個介入就是讓User-level Thread與Kernel-level Thread綁定在一起。<br>而當User-level Thread需要與硬體溝通，他就會先與Kernel-level Thread溝通，</p>
<h3 id="Kernel-Mode-vs-User-Mode"><a href="#Kernel-Mode-vs-User-Mode" class="headerlink" title="Kernel Mode vs User Mode"></a>Kernel Mode vs User Mode</h3><p>我把他理解成是兩種不同的權限，為什麼需要兩種特權呢?</p>
<blockquote>
<p>為了避免一個使用者的程式修改其他使用者的程式甚至是系統核心， 並且更進一步，讓作業系統可以壟斷所有的硬體資源，大部分的機器(或者 CPU)至少會有二個執行特權(privilege)：Kernel mode (又稱 System mode) 與 User mode。<br>– <a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a></p>
</blockquote>
<p>既然知道這兩者模式的差異，那又跟Kernel有什麼關係呢?</p>
<blockquote>
<p>Kernel mode is the CPU’s “natural” mode, with no restrictions (on x86 CPUS - “ring 0”). User mode (on x86 CPUs - “ring 3”) is when the CPU is instructed to trigger an interrupt whenever certain instructions are used or whenever some memory locations are accessed. This allows the kernel to have the CPU execute specific kernel code when the user tries to access kernel memory or memory representing I&#x2F;O ports or hardware memory such as the GPU’s frame buffer.<br>– <a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a></p>
</blockquote>
<p>大概意思是，在程式要求執行一些動作時，若他不具有特定權限，Kernel也能夠去要求CPU執行一些相對的Kernel code去中斷目前的Process。<br>這樣讓開發者少掉維護或檢查影響到其他的程式的壓力跟錯誤。</p>
<p>如果是web後端，用最優先的middleware來理解Kernel是不是會容易些?</p>
<h3 id="User-Thread-x2F-User-level-Thread"><a href="#User-Thread-x2F-User-level-Thread" class="headerlink" title="User Thread &#x2F; User-level Thread"></a>User Thread &#x2F; User-level Thread</h3><p>擁有user mode權限的thread，透過特定介面的library建立的，OS並不知道他們的存在，但在要工作時，會mapping到Kernel thread上。<br>特性: </p>
<ul>
<li>產生、管理的成本低</li>
<li>舉例像是: POSIX Pthreads, Win32 threads, Java threads</li>
</ul>
<h3 id="Kernel-Thread-x2F-Kernel-level-Thread"><a href="#Kernel-Thread-x2F-Kernel-level-Thread" class="headerlink" title="Kernel Thread &#x2F; Kernel-level Thread"></a>Kernel Thread &#x2F; Kernel-level Thread</h3><p>僅運行kernel code且與user space(memory) process毫無關聯的Thread。<br>並且我們知道thread一定在process之中，而Kernel thread就是Kernel這個Process產生出來的thread</p>
<ul>
<li>CPU能查覺到存在的其實是Kernel-level Thread，而非mapping於他的User-level Thread。</li>
<li>舉例像是: Windows 2000(NT), Solaris, Linux</li>
</ul>
<h2 id="多執行緒模式"><a href="#多執行緒模式" class="headerlink" title="多執行緒模式"></a>多執行緒模式</h2><p>由上，我們會知道，所以在user mode的Process要操作到硬體的部分是需要經過kernel thread。<br>而這個對映的方式稱為mapping，mapping的方式共有三種:</p>
<ul>
<li>多對一</li>
<li>一對一</li>
<li>多對多</li>
</ul>
<h3 id="多對一"><a href="#多對一" class="headerlink" title="多對一"></a>多對一</h3><p><img src="https://i.imgur.com/Sd5bMmQ.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到一個Kernel-level Thread</li>
<li>優點:<ul>
<li>Thread管理在user space(memory)完成，效率高</li>
</ul>
</li>
<li>缺點:<ul>
<li>整個process可能會因為其中一個user thread發出的指令而導致block。</li>
<li>因為OS僅察覺到一個kernel thread，如果在一個以thread數量平分cpu使用使間的系統中，他的單位仍是一。</li>
<li>只有一個thread可以訪問kernel，就算是多processor的環境也無法平行。</li>
</ul>
</li>
</ul>
<h3 id="一對一"><a href="#一對一" class="headerlink" title="一對一"></a>一對一</h3><p><img src="https://i.imgur.com/IxbwdDb.png"></p>
<ul>
<li>定義: 一個User-level Thread mapping到一個Kernel-level Thread</li>
<li>例子: Linux, Windows XP&#x2F;NT&#x2F;2000</li>
<li>優點:<ul>
<li>所有多對一的缺點的相反。</li>
</ul>
</li>
<li>缺點:<ul>
<li>產生一個thread時就同時產生kernel thread，負擔較高</li>
<li>所有的操作都會進行system call，要進行前者的動作，需要將權限改為kernel mode，而這是一個昂貴的操作</li>
</ul>
</li>
</ul>
<h3 id="一對多"><a href="#一對多" class="headerlink" title="一對多"></a>一對多</h3><p><img src="https://i.imgur.com/SHSoik1.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到多個Kernel-level Thread</li>
<li>優點:<ul>
<li>可在多Processor系統中平行執行。</li>
<li>某個thread被block後可安排其他kernel thread執行</li>
</ul>
</li>
<li>缺點:<ul>
<li>需要user thread 管理器與 kernel thread 管理器支援這種協調。</li>
</ul>
</li>
</ul>
<h2 id="node-js的有趣事實"><a href="#node-js的有趣事實" class="headerlink" title="node.js的有趣事實"></a>node.js的有趣事實</h2><p>關於node.js，他究竟是不是單執行緒的runtime呢?<br>他像是，但其實並不是的。<br>他一共有7個執行緒，包括1個執行JS的主執行緒、4個node.js執行緒、2個V8執行緒。</p>
<h3 id="調查多執行緒的事實"><a href="#調查多執行緒的事實" class="headerlink" title="調查多執行緒的事實"></a>調查多執行緒的事實</h3><p>要證明這件事情其實意外的容易:</p>
<ol>
<li>先做一個可以永久執行的node.js，例如web server或是無限while迴圈之類的</li>
<li>取得PID<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps | grep node</span><br></pre></td></tr></table></figure></li>
<li>查看執行緒<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br><span class="line"># -H可以顯示行程中的執行緒</span><br><span class="line"># -P指定特定PID</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你就可以看到7個執行緒了<br>不過4個node.js的執行緒其實只會做I&#x2F;O相關的工作，如果遇到CPU密集的工作，其實還是會發生JS主執行緒阻塞而導致整個Process阻塞的狀況。</p>
<h3 id="worker-threads-module"><a href="#worker-threads-module" class="headerlink" title="worker-threads module"></a>worker-threads module</h3><p>node.js v12開始支援worker-threads，於是剛剛提到的CPU密集型的工作就可以透過模組建立新的thread去承接這個工作。<br>詳細有興趣的人可以去<a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js"></a>跟著教學一起玩一下，蠻有意思的喔!</p>
<h3 id="cluster-module"><a href="#cluster-module" class="headerlink" title="cluster module"></a>cluster module</h3><p>cluster則是支援建立主Process的child processes，而官方的資料也確實提到，若沒有隔離行程的必要，就使用worker-threads代替。</p>
<blockquote>
<p>Clusters of Node.js processes can be used to run multiple instances of Node.js that can distribute workloads among their application threads. When process isolation is not needed, use the worker_threads module instead, which allows running multiple application threads within a single Node.js instance.<br><a href="https://nodejs.org/api/cluster.html">node.js</a></p>
</blockquote>
<p>不過根據官方文件以及在實務上看到cluster的用法，cluster更像是一種負載平衡的機制，worker-threads則可以用來應付CPU密集的工作，所以我覺得完全有可能混用他們!</p>
<p>也確實有stackoverflow的回答這樣認為~</p>
<blockquote>
<p>Which is better? It depends on the problem you’re solving. Worker threads are for long-running functions. Clustering makes a server able to handle more requests, by handling them in parallel. You can use both if you need to: have each nodejs cluster process use a worker thread for long-running functions.<br><a href="https://stackoverflow.com/questions/61328960/when-is-better-using-clustering-or-worker-threads">When is better using clustering or worker_threads?</a></p>
</blockquote>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然寫的辛苦，但總算對於Program、Process、Thread有了更進一步的了解。<br>而且回過頭來，我覺得這樣我在使用一些與Thread以及Process相關的功能時也能更有把握些。<br>想起第一次面試時，當時考官就問我node.js是否是單執行緒這個問題，結果直到今天我才有辦法稍稍好一點的回答這個問題XD</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>發現我用了一些中文單字其實是有中、台兩種說法的，參照<a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">此篇</a>特意列出，避免混淆。</p>
<ul>
<li>concurrent:<ul>
<li>台灣：並行</li>
<li>大陸：並發</li>
</ul>
</li>
<li>parallel:<ul>
<li>台灣：平行</li>
<li>大陸：並行</li>
</ul>
</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.kshuang.xyz/doku.php/operating_system:course_concept:thread">Thread</a><br><a href="https://hackmd.io/@Chang-Chia-Chi/OS-CH4">作業系統 CH4 Multithreaded Programming</a><br><a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">Difference between user-level and kernel-supported threads?</a><br><a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">核心</a><br><a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a><br><a href="https://medium.com/@akhandmishra/operating-system-threads-and-concurrency-aec2036b90f8">Operating System: Threads and Concurrency</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js">https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js</a><br><a href="https://blog.appsignal.com/2021/02/03/improving-node-application-performance-with-clustering.html">Improving Node.js Application Performance With Clustering</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
</search>
