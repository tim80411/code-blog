<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>先生你誰?-身分驗證Authentication (Oauth, Basic, JWT, token)</title>
    <url>/code-blog/2022/10/04/API_Authenticate/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面不管是在提到HTTP這個應用協定或是REST的風格，都有提到無狀態(stateless)這個特性。</p>
<p>這個特性其中一個目的是希望可以將每次的request都隔離，讓各request不用依賴其他的請求，僅依靠自己單個請求身上所帶的資料完成目的。</p>
<p>但我們回想類似FB, Google，有許多服務的商業模式都是以「會員制」作為基礎，那我們該如何在維持無狀態的特性下，實現這樣的會員制，讓伺服器「認得」請求呢?</p>
<p>今天就會談到這個部分: 「驗證Authenticate」。</p>
<span id="more"></span>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其實不管是哪種驗證過程，最終的目的就是要讓伺服器可以「認得」你是誰。</p>
<p>不過「認得」這個字眼實在太過哲學。</p>
<p>想想，如果有一天你已經7, 80歲，突然有個陌生人說他是你的某某國小同學，你該怎麼認得出來是他呢?</p>
<p>最終我們憑藉認得一個人的方式大概分兩種:</p>
<ol>
<li>只有當事人跟你才知道的知識: 共同的回憶、秘密。</li>
<li>只有當事人才有的東西: 身分證、長相。</li>
</ol>
<p>根據不同情境其實這兩個概念可以講出的東西可能有點不太一樣。<br>比如看電影的時候，門口的人看的是門票，他相信的是，只有當事人才會那個座位的電影票，所謂的認票不認人。</p>
<p>回到程式這邊，不知道腦筋有沒有開始自動分類常見的驗證機制?</p>
<ol>
<li>共同知識: 帳號、密碼、密碼提示問題…等等。</li>
<li>獨有物品: email、電話號碼、密碼卡、指紋、面部特徵…等等。</li>
</ol>
<p>這兩個類別可能會重疊，比如，伺服器會記錄你的電話號碼，並且在你請求時發送一次性密碼。</p>
<p>概念大致如此，我們實作上一般可分為兩種驗證策略(註1)。</p>
<p>註1: 大部分的驗證策略其實是一種「約定」，這指的是，我們通過一種有共識的做法減少溝通鎖需要的成本。</p>
<h2 id="Basic-Authentication"><a href="#Basic-Authentication" class="headerlink" title="Basic Authentication"></a>Basic Authentication</h2><p>這是一個透過Header來進行驗證的策略，你可以想像你每次要進到一間店裡，都得告訴他你的帳號跟密碼才會放行。<br><img src="https://i.imgur.com/hJGqG3B.png" alt="圖 6"> </p>
<h3 id="概要流程"><a href="#概要流程" class="headerlink" title="概要流程"></a>概要流程</h3><ol>
<li>一個有因應此策略的client訪問一個使用Basic Authentication的server</li>
<li>伺服器會檢查在Header裡的Authorization欄位，規格應為 <code>Authorization: Basic &lt;value&gt;</code></li>
<li>此時因為沒有Authorization並沒有資料，server按照約定會回傳401 status code並在Header上加上 <code>WWW-Authenticate: Basic realm=&quot;&lt;value&gt;&quot;</code></li>
<li>client當發現得到以上的回應後，會出現一個給予使用者輸入用戶名稱及密碼的地方</li>
<li>client將用戶名稱跟密碼做成一個base64的資料，虛擬碼表示為: <code>base64(username:password)</code></li>
<li>client將資料放到Header: <code>Authorization: base64(username:password)</code></li>
<li>server重複2開始的動作。</li>
</ol>
<h3 id="原則"><a href="#原則" class="headerlink" title="原則"></a>原則</h3><p>從上面的流程我們可以整理出Basic Authentication的一些原則</p>
<ol>
<li>client使用<code>Authorization: Basic &lt;value&gt;</code> 放置待驗證資料(每次請求都會放)</li>
<li>約定使用base64編碼&#x2F;解碼: 用於將不相容的資料轉換HTTP相容的字元</li>
<li>server使用<code>WWW-Authenticate: Basic realm=&quot;&lt;value&gt;&quot;</code> 與client告知結果。</li>
</ol>
<h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ul>
<li>簡單易用</li>
<li>大部分的瀏覽器都有支援</li>
</ul>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ul>
<li>幾乎是明碼傳輸帳密</li>
<li>瀏覽器保存通過驗證的資訊，但沒有提供Server如何透過HTTP指示刪除，意味除了關閉瀏覽器或分頁，沒辦法登入使用者</li>
</ul>
<h3 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h3><ul>
<li>通常會搭配HTTPS使用</li>
<li>在安全內網應用</li>
</ul>
<h2 id="Token-Based-Authentication"><a href="#Token-Based-Authentication" class="headerlink" title="Token Based Authentication"></a>Token Based Authentication</h2><p>相較於Basic Authentication把用戶名稱及密碼帶在每次request上，Token Based Authentication則是改將一個名為Token的資訊帶在每次request上以代替前者。</p>
<p>Token是什麼呢?指的是一段由server提供給client端以作為驗證身分的字串。</p>
<p>你可以想像你走進店裡的時候，先用「某種方式」讓警衛認得你，而後警衛就念給你一串無意義的字，告訴你在一段時間內，可以不用用前面的方式進到店裡，念給他那串字就可以。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://i.imgur.com/vWP7Sia.png" alt="圖 7"></p>
<h3 id="Token的特徵"><a href="#Token的特徵" class="headerlink" title="Token的特徵"></a>Token的特徵</h3><ul>
<li>看似隨機、無意義的資料</li>
<li>被放在 <code>Authorization: &lt;method&gt; &lt;value&gt;</code></li>
<li>(可選)具有使用期限</li>
<li>(可選)具有驗證用的資訊</li>
</ul>
<h3 id="優點-1"><a href="#優點-1" class="headerlink" title="優點"></a>優點</h3><ul>
<li>安全</li>
</ul>
<p>相對於使用Basic Authentication安全，主要是避開每次request都需要帶上沒有經過雜湊或加密的username和password。</p>
<p>以前面的例子來說，你每次都跟警衛講用戶名稱跟密碼，會不會哪天就被聽到了?</p>
<ul>
<li>可帶資訊</li>
</ul>
<p>透過一些加密的方式，可以讓token本身帶有資訊可以被client解析。</p>
<ul>
<li>可控制</li>
</ul>
<p>跟前面可帶資訊有關，透過帶著過期的資訊讓資料在指定的時間無法在被使用或拋棄。</p>
<h3 id="產生token的方法"><a href="#產生token的方法" class="headerlink" title="產生token的方法"></a>產生token的方法</h3><ol>
<li>SWT(Simple Web Token)</li>
<li>JWT(JSON Web Token)</li>
</ol>
<p>這兩個的比較可以參考以下</p>
<blockquote>
<p>Appendix C.  Relationship of JWTs to Simple Web Tokens (SWTs)</p>
<p> Both JWTs and SWTs [SWT], at their core, enable sets of claims to be<br> communicated between applications.  For SWTs, both the claim names<br> and claim values are strings.  For JWTs, while claim names are<br> strings, claim values can be any JSON type.  Both token types offer<br> cryptographic protection of their content: SWTs with HMAC SHA-256 and<br> JWTs with a choice of algorithms, including signature, MAC, and<br> encryption algorithms.<br>– <a href="https://tools.ietf.org/html/rfc7519#appendix-C">JSON Web Token (JWT)</a></p>
</blockquote>
<p>概要的意思是:</p>
<ol>
<li>兩個產生的目的都是為了在應用程式間溝通</li>
<li>SWT組成value的方式是string, JWT是JSON</li>
<li>SWT雜湊的方式是HMAC SHA-256, JWT則是可選的雜湊演算法</li>
</ol>
<p>稍微介紹一下目前比較常見的JWT的結構跟製作流程:</p>
<h4 id="組成"><a href="#組成" class="headerlink" title="組成"></a>組成</h4><p>包括: Header, Payload, Signature，這三者會以(.)做分隔<br><img src="https://tyk.io/docs/img/dashboard/system-management/jwt_jwtio_example.png"></p>
<blockquote>
<p>圖片來自<a href="https://tyk.io/docs/basic-config-and-security/security/authentication-authorization/json-web-tokens/">JSON Web Tokens</a></p>
</blockquote>
<ul>
<li>Header: 包含是否要簽章、雜湊演算法的訊息</li>
<li>Payload: 資料</li>
<li>Signature: 簽章</li>
</ul>
<h4 id="製作過程"><a href="#製作過程" class="headerlink" title="製作過程"></a>製作過程</h4><ol>
<li>按照需求產出Header, Payload</li>
<li>將Header做base64得到<code>base64(Header)</code></li>
<li>將Payload做base64得到<code>baser64(Payload)</code></li>
<li>從伺服器得到一個秘密字串稱為secret</li>
<li>(若HMACSHA256)將<code>base64(Header)</code>及<code>baser64(Payload)</code>使用secret做雜湊，參考下方虛擬碼</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Signature虛擬碼</span><br><span class="line">HMACSHA256(base64(header) + &#x27;.&#x27; + base64(payload), secret)</span><br></pre></td></tr></table></figure>

<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>稍稍了解了有關於驗證的知識，略過了關於cookie、session的概念，以及基於token延伸出的OAuth，有興趣可以再去找相關資訊。</p>
<p>那就這樣啦，明天見~</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://swoopnow.com/user-authentication/">User Authentication: Understanding the Basics &amp; Top Tips</a><br><a href="https://roadmap.sh/guides/token-authentication">Token Based Authentication</a><br><a href="https://zh.wikipedia.org/zh-tw/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81">HTTP基本認證</a><br><a href="https://codingnote.com/2021/01/18/jwt-intro-1/">深入理解JSON Web Token系列1：JWT的历史</a><br><a href="https://pjchender.dev/webdev/note-jwt/">產生 JWT</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Basic Authentication</tag>
        <tag>Token Based Authentication</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>常見的API架構比較</title>
    <url>/code-blog/2022/10/03/API_Design_Pattern/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在網路開發中，最常見的就是以HTTP協定與其他端點溝通，但各自使用不同的內容及結構可能會造成困擾。<br>比如不同的服務都需要閱讀各自的文件並適應不同的格式，於是為了解決這個問題，出現了諸如SOAP, REST, gRPC, graphQL等用來規範彼此如何規範的技術。</p>
<p>雖然聽起來有點複雜，但大致來說，他們想解決的事情就是:</p>
<blockquote>
<p>如何訪問 Web 服務</p>
</blockquote>
<p>今天會對不同的架構各自有些介紹，那就開始吧～</p>
<span id="more"></span>

<h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><p>是一種完全依賴XML進行傳輸且經過明確規範的協定，當初建立的目的是包括:</p>
<ol>
<li>抽象化介面: 讓不同語言都可以透過相同的格式取得資料。</li>
<li>擴展性: 根據不同需求選用類似於Header的結構，像是: WS-ReliableMessaging, WS-Coordination。</li>
<li>多網路協定可用: SMTP…等</li>
</ol>
<p>正因為他是明確的協定，所以如果不遵守規則就無法使用他，另外，相較於REST，因為解析規則、標準的必要開銷，以及內部包含的大量訊息，所以他普遍被認為成本更高。</p>
<p><img src="https://i.imgur.com/bXUoRAb.png" alt="圖 1">  </p>
<blockquote>
<p>– <a href="https://zh.wikipedia.org/zh-tw/%E7%AE%80%E5%8D%95%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">維基百科</a></p>
</blockquote>
<p>在使用的時候通常會搭配網路服務描述語言(Web Service Description Language, WSDL)，告訴我們如何解析一個SOAP server，而這樣的過程通常可以透過第三方套件來自動處理。<br>所以使用SOAP的好處就是，因為SOAP是經過明確定義的結構，因此可以自動化處理不論XML的產出或是解析，讓我們使用其他Web Server的元件就像是在使用function一樣。</p>
<h3 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h3><ul>
<li>需要高度結構化、有限制的傳輸</li>
<li>狀態性的</li>
</ul>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>相對於SOAP，REST更像是一種準則或建議，甚至是風格，並不強調完全遵守。<br>REST的全名為表現層狀態轉換，只要遵守一下規則的就可以稱他為RESTful服務:</p>
<ul>
<li>Client-Server</li>
<li>Stateless: 需假設服務並不知道當前的狀態，</li>
<li>Cache: 可以將資料做緩存</li>
<li>Uniform Interface: 統一的資源介面，使責任分離，client並不用知道server如何實作</li>
<li>Layered System: client端並不知道使用的url是否直接連到server，可以經過層層伺服器。</li>
</ul>
<p>所以RESTful API就是遵守以上架構風格的API，特別針對統一介面來說明</p>
<ol>
<li>資源: 使用名詞</li>
<li>動詞: 使用HTTP method</li>
<li>回應: http code</li>
</ol>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://www.example.com/users</span><br></pre></td></tr></table></figure>

<p>在統一介面下，可以清楚的知道這是取得所有users的資料的一條API。</p>
<h3 id="使用時機-1"><a href="#使用時機-1" class="headerlink" title="使用時機"></a>使用時機</h3><ul>
<li>有限的網路速度: 因為資料格式較小, 故傳輸要求較小</li>
<li>快速實現: 因為標準、強制規則較少，可以快速編寫程式碼</li>
<li>緩存需要: 如果需要緩存，因為統一了介面，所以可以針對固定介面保存資料，減少對於server的請求</li>
</ul>
<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>RPC指的是remote procedure call，原本在1980左右產生，當時就是為了解決電腦間的溝通，而在現在，由google在這個概念之上發展了gRPC，使用Protocol Buffers來描述資料如何交換，提供了另一種有別於RESTful的溝通方式。</p>
<p>那gRPC是什麼呢？用中文來說就是「遠端程式呼叫系統」<br>意思就是呼叫API時就像呼叫自己的函式一樣。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>編寫.proto定義</li>
<li>client 直接使用定義好的function</li>
</ul>
<h3 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h3><ul>
<li>快且小: 因為資料傳輸被編譯成二進制; 關於人類不可讀這點視情況決定是好是壞。</li>
<li>直觀得命名: 因為是直接使用function name，可依據需要像是取用function一樣做取名。</li>
<li>跨程式: Protocol Buffer可以根據語言編譯不同檔案。</li>
<li>強型別: 型別明確。</li>
<li>文件化: proto檔案可以寫註解，可以說定義本身就是文件。</li>
</ul>
<h2 id="graphQL"><a href="#graphQL" class="headerlink" title="graphQL"></a>graphQL</h2><h2 id="簡介-1"><a href="#簡介-1" class="headerlink" title="簡介"></a>簡介</h2><p>一種讓使用者可以通過定義好的語法取得指定的資料及修改指定的資料。</p>
<p>通常會拿它來和RESTful api做比較，相較於後者:</p>
<ul>
<li>較小的資料傳輸: 因為可以指定資料，就可以讓資料在最小限度下傳輸</li>
<li>可重複使用的介面: 因伺服器僅是定義資料schema，不用為了需求的變耕重複修改api</li>
</ul>
<p>某種程度上你可以說他跟SQL還真的蠻像的XD</p>
<h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><ul>
<li>分層Hierarchical: 為了資料的多層結構，graphQL也配合這樣的概念進行分層query。</li>
<li>產品中心Product‐centric: 以畫面的需求為主。</li>
<li>強型別Strong‐typing</li>
<li>客戶客製化搜尋Client‐specified queries: 可以針對client端的需求客製化每次的query並處理。</li>
<li>內省(自我查詢的)Introspective: 翻譯內省其實有點怪，不過他的意思大致是說，他自己的型別可以透過graphQL的語法搜尋出來。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>他大致的流程如下:</p>
<ol>
<li>client端呼叫graphQL query</li>
<li>後端解析query產生AST語法樹語法樹</li>
<li>檢驗是否有語法錯誤</li>
<li>執行query</li>
<li>傳送</li>
</ol>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>一次性了解不同的訪問web service的方式確實有點吃力，很多部分都只寫到最淺顯的部分…<br>剩下的部分就交給未來的自己了，現在至少可以在別人提到這個字的時候點頭然後不會睜眼瞎了XDD</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.redhat.com/en/topics/integration/whats-the-difference-between-soap-rest">REST vs. SOAP</a><br><a href="https://smartbear.com/blog/soap-vs-rest-whats-the-difference/">SOAP vs REST. What’s the Difference?</a><br><a href="https://coherence0815.wordpress.com/2016/02/11/why-soap/">Why SOAP</a><br><a href="https://zh.wikipedia.org/zh-tw/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">表現層狀態轉換</a><br><a href="https://pjchender.dev/golang/grpc-getting-started/">[gRPC] gRPC Getting Started</a><br><a href="https://ithelp.ithome.com.tw/articles/10200678">https://ithelp.ithome.com.tw/articles/10200678</a><br><a href="http://spec.graphql.org/draft/#sec-Overview">graphQL</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>API</tag>
        <tag>RESTful</tag>
        <tag>SOAP</tag>
        <tag>gRPC</tag>
        <tag>graphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>交易的安全保證-ACID &amp; Transactions</title>
    <url>/code-blog/2022/10/01/DB_ACID_And_Transaction/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在真實的網路行為上，一個只是點擊的動作常常會牽動對於多個數據的動作，這樣一系列動作的組成被稱為Transaction，中文有人說事務，也有人稱呼他為交易。<br>而ACID則是確保Transaction能正確可靠的四個特性。</p>
<p>後面會來稍微了解這個部分~</p>
<span id="more"></span>
<h2 id="Transaction錯誤"><a href="#Transaction錯誤" class="headerlink" title="Transaction錯誤"></a>Transaction錯誤</h2><p>剛剛前提已經提到了關於Transaction的定義。<br>原則上，我們會希望當Transaction進行的時候，資料庫要像是時間停止一樣，直到commit之前所有的資料都保持不動；<br>而其他的事務的操作若有取得與前面事務相關的資料時，應該以前面事務的最終結果為結果。<br>ANSI&#x2F;ISO standard SQL 92舉出一些並非如此的錯誤: </p>
<ul>
<li>髒讀Dirty Reads</li>
<li>不可重複讀Non-Repeatable Reads</li>
<li>幻讀Phantom Reads</li>
</ul>
<h3 id="Dirty-Reads"><a href="#Dirty-Reads" class="headerlink" title="Dirty Reads"></a>Dirty Reads</h3><blockquote>
<p>有兩個Transaction分別為A及B，若A的操作將包含更改一個欄位的資料，B這時候在A尚未commit(註1)的時候去讀取，並取得了更新後的結果，這就稱為Dirty Reads</p>
</blockquote>
<p>為什麼這樣是一種錯誤呢?原因在於A並未確定已經成功了，若他失敗，將會把資料從已更新的資料退回，這時候B使用到的值就是錯誤的。</p>
<ul>
<li>白話案例:<br>假如有一個Transaction A的目的是將user的身分從一般normal轉成VIP，在更新完但還沒commit時，這時候Transaction B出現，他希望使用一個VIP才能使用的優惠，此時讀取的資料若是VIP，就能順利完成Transaction B，並用掉了優惠；沒想到這時候發現Transaction A後面在完成某個確認的流程沒有通過，於是所有動作都退回，導致使用者的身分其實還是normal卻使用了VIP才能用的優惠。</li>
</ul>
<p>註1: 一個Transaction的commit代表在這個Transaction的所有操作都被確定完成了。</p>
<h3 id="Non-Repeatable-Reads"><a href="#Non-Repeatable-Reads" class="headerlink" title="Non-Repeatable Reads"></a>Non-Repeatable Reads</h3><blockquote>
<p>一個Transaction裡面，讀取兩次相同欄位，卻得到不同結果，稱為Non-Repeatable Reads</p>
</blockquote>
<h3 id="Phantom-Reads"><a href="#Phantom-Reads" class="headerlink" title="Phantom Reads"></a>Phantom Reads</h3><blockquote>
<p>一個Transaction裡面，進行兩次查詢，得到不同數量的結果，就稱為Phantom Reads</p>
</blockquote>
<p>看起來跟Non-Repeatable Reads有點相像，差異應該是讀取的層級不太一樣，以SQL的講法，Phantom Reads是發生在table內的等級，而Non-Repeatable Reads則是row內的等級，所以意思是，Non-Repeatable Reads跟Phantom Reads確實是可能在同一次搜尋裡面發生的。</p>
<h2 id="ACID-原則"><a href="#ACID-原則" class="headerlink" title="ACID 原則"></a>ACID 原則</h2><p>為了避免上述的錯誤，大部分的關聯式資料庫都遵循這個原則，包括</p>
<ul>
<li>原子性Atomicity</li>
<li>一致性Consistency</li>
<li>隔離Isolation</li>
<li>持久性Durability</li>
</ul>
<h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>全有全無，Transaction的操作要就全部發生，要就全部沒有，視為一個整體。</p>
<p>有一個說法是我覺得很清楚的</p>
<blockquote>
<p>一般來說，原子性 意為某樣東西不可在被切割的更小塊。但在計算機領域中，則是指在多執行緒底下，某個執行緒若執行一個原子操作 (atomic operation)，另一個執行緒無法看到該操作中的半完成狀態，只有操作前跟操作後兩個狀態。<br>– <a href="https://ithelp.ithome.com.tw/articles/10259236">Transactions (1) - ACID</a></p>
</blockquote>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><blockquote>
<p>在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設約束、觸發器、級聯回滾等<br>– <a href="https://zh.wikipedia.org/zh-tw/ACID">維基百科</a></p>
</blockquote>
<p>這邊在維基百科其實說的有點抽象，但我看到一些其他的說法，包括: </p>
<ul>
<li>data is consistent before and after a transaction without any missing steps–<a href="https://retool.com/blog/whats-an-acid-compliant-database/">參考</a></li>
<li>transaction 完成前後，資料都必須永遠符合 schema 的規範，保持資料與資料庫的一致性–<a href="https://tw.alphacamp.co/blog/mysql-intro-acid-in-databases">參考</a></li>
<li>不同的數據都會有一些基本的約束，而這些約束在交易前跟交易後都必須要遵守，如果沒辦法遵守交易就必須失敗–<a href="https://lance.coderbridge.io/2021/04/24/short-what-is-acid/">參考</a></li>
</ul>
<p>我覺得一致性這邊要提到的約束其實是泛指所有，上面的說法都可能是其中一個部分，比如schema可能會限制unique index、另外不在schema中的約束可能是FK constraint等等的。</p>
<p>不過這裡的一致性也部分受到原子性保護著，比如說錯誤的操作因為原子性的全有全無機制，不會因此出現例外，而是會回到原本的狀態，這樣也就確保錯誤時的一致性不會被破壞了。</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>這裡指的是當多個Transaction併發(concurrent)時，不會互相造成影響。</p>
<p>最完美的作法當然後依序執行，也就是每次只完成一個Transaction，但這樣效能太差，這不就代表沒有併發嗎XD。<br>所以後面就會出現不同等級的隔離，都相對於依序執行隔離來的弱，有機率發生併發，但是在效能、情境上考量後可接受。<br>而開發者就需要了解不同層級的差異，以盡可能減少併發造成的bug，也就是前面提到的三種錯誤。</p>
<p>以下分為幾個層級，由低到高分別為: </p>
<h4 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h4><p>保證A事務已更新但未commit的資料，B事務僅可讀取。<br>因為可以讀取其他Transaction尚未commit的結果，其實意思幾乎等同於沒隔離了XD<br>不過他的意義還是在的，想像一下若沒有這層隔離會發生的狀況:</p>
<ol>
<li>原始資料X為0</li>
<li>事務A更新資料X為1</li>
<li>事務B更新資料X為2</li>
<li>事務A rollback 回原值0</li>
</ol>
<p>原本預期嘗試更新為2就因此消失了，因此此層還是能至少避免更新的遺失。</p>
<p>此隔離性會發生的問題包括:</p>
<ul>
<li>髒讀</li>
<li>不可重複讀</li>
<li>幻讀</li>
</ul>
<h4 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h4><p>保證讀取到的資料都是經過確認(commit)的。<br>因此可以避免髒讀。</p>
<p>為什麼無法避免其餘錯誤呢?<br>有一個案例如下</p>
<ol>
<li>原始資料X為1</li>
<li>事務A讀取資料X得到1</li>
<li>事務B更新資料X為2並確認</li>
<li>事務A讀取資料X得到2</li>
</ol>
<p>這樣就發生不可重複讀了。<br>同上，如果這裡的更新變成插入資料一樣無法避免幻讀。</p>
<p>此隔離性會發生的問題包括:</p>
<ul>
<li>不可重複讀</li>
<li>幻讀</li>
</ul>
<h4 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h4><p>保證同一次事務，取得的資料都相同。</p>
<p>此隔離性會發生的問題包括:</p>
<ul>
<li>幻讀</li>
</ul>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>以效能換取隔離。</p>
<h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>若Transaction完成，就算出現錯誤，已經完成操作的資料也應該保持原樣、永久的。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次大致了解了Transaction，以及保持Transaction正確可靠的ACID。<br>不過其中在隔離性的部分雖然介紹了層級，但各資料庫實現這些層級隔離的方式完全是看他們自己XD<br>通常會應用到關於鎖Lock的觀念，不過這部分就只好留待以後了~~</p>
<p>明天會了解一下與DB效能有關的話題-N+1 problem。</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10259236">Transactions (1) - ACID</a><br><a href="https://fauna.com/blog/database-transaction">What is a database transaction?</a><br><a href="https://openhome.cc/Gossip/HibernateGossip/IsolationLevel.html">簡介隔離層級</a><br><a href="https://ithelp.ithome.com.tw/articles/10247232">Transaction 併發錯誤與隔離層級 - (1)</a><br><a href="https://blog.amis.com/database-transaction-isolation-a1e448a7736e">資料庫交易的 Isolation</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>ACID</tag>
        <tag>Transaction</tag>
        <tag>Isolation</tag>
      </tags>
  </entry>
  <entry>
    <title>效能危機-N+1 problems</title>
    <url>/code-blog/2022/10/02/DB_N_Plus_One_Problem/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有個好故事可以回答什麼是N+1 problems: </p>
<blockquote>
<p>假如有一天你拿到一份食譜，希望製作蘋果派，你待在廚房裡，食材都在儲藏室，你需要去拿:</p>
<ol>
<li>你需要蘋果，於是你去了一趟儲藏室。</li>
<li>你需要糖，於是你是去了一趟儲藏室。</li>
<li>你需要麵粉，於是你去了一趟儲藏室，然後你發現今天已經快過完了XD</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>你一定在吐槽，不能一次看完，然後再一起從儲藏室把食材拿回來嗎？<br>沒錯，這麼麻煩的部分就是N+1 problems提到的，我們現在改用描述現象的方式解釋N+1 problems：</p>
<blockquote>
<p>在查詢主資料時，為了取得有與主資料有關連的資料，重複的查詢相同資料。</p>
</blockquote>
<p>用SQL來表示一下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;Recipes&#x27;</span> <span class="keyword">WHERE</span> Recipes.id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">-- 取得食譜1的資料</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;Foods&#x27;</span> <span class="keyword">WHERE</span> Foods.id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">-- 取得食材1的資料</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;Foods&#x27;</span> <span class="keyword">WHERE</span> Foods.id <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="comment">-- 取得食材2的資料</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;Foods&#x27;</span> <span class="keyword">WHERE</span> Foods.id <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span> <span class="comment">-- 取得食材3的資料</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;Foods&#x27;</span> <span class="keyword">WHERE</span> Foods.id <span class="operator">=</span> <span class="string">&#x27;4&#x27;</span> <span class="comment">-- 取得食材4的資料</span></span><br><span class="line"><span class="comment">-- 以此類推N個，看取得食譜1時包含多少個Foods需要被查詢</span></span><br></pre></td></tr></table></figure>

<h2 id="錯誤發生的原因"><a href="#錯誤發生的原因" class="headerlink" title="錯誤發生的原因"></a>錯誤發生的原因</h2><p>先總結的話，可以說是在使用關聯式資料庫且在應用程式層沒有處理好搜尋造成的錯誤。<br>不過實際狀況，常發生在使用ORM不當的狀況下。</p>
<p>以node.js搭配sequelize這個SQL的ORM來操作SQL為例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">  <span class="comment">// 省略了sequelize的設定、對Recipe及Food的引入。</span></span><br><span class="line">  <span class="keyword">const</span> recipes = <span class="keyword">await</span> <span class="title class_">Recipe</span>.<span class="title function_">findAll</span>(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;); <span class="comment">// 取得食譜1的資料</span></span><br><span class="line">  <span class="keyword">const</span> foods = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> recipe <span class="keyword">of</span> recipes) &#123; <span class="comment">// 取得n次食材的資料</span></span><br><span class="line">    <span class="keyword">const</span> foodId = recipe.<span class="property">foodId</span>;</span><br><span class="line">    <span class="keyword">const</span> food = <span class="keyword">await</span> <span class="title class_">Foods</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">id</span>: foodId&#125;);</span><br><span class="line">    foods.<span class="title function_">push</span>(food)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>正因為關聯式資料庫的資料並未存在單獨的table身上，可能僅是存了FK在db，為了透過FK取得其他table的資料。<br>就使用了迴圈一一收集資料，造成了n+1 problems。</p>
<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>如果熟悉SQL，其實要解決這樣的問題倒是蠻容易的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Recipes </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Foods <span class="keyword">on</span> Recipes.food_id <span class="operator">=</span> Foods.id</span><br><span class="line"><span class="keyword">WHERE</span> Recipes.id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>也就是直接透過JOIN將資料做成一個新的table，而後續的query都直接使用此新的table，就沒有重複搜尋資料的問題了。</p>
<p>在sequelize這裏，我們可以參考<a href="https://sequelize.org/docs/v6/advanced-association-concepts/eager-loading/">官方文件</a></p>
<blockquote>
<p>As briefly mentioned in the associations guide, eager Loading is the act of querying data of several models at once (one ‘main’ model and one or more associated models). At the SQL level, this is a query with one or more joins.</p>
</blockquote>
<p>如果是在node.js透過Sequelize提供的includes介面，我們也可以完成JOIN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">  <span class="comment">// 省略了sequelize的設定、對Recipe及Food的引入。</span></span><br><span class="line">  <span class="keyword">const</span> recipes = <span class="keyword">await</span> <span class="title class_">Recipe</span>.<span class="title function_">findAll</span>(&#123;</span><br><span class="line">    <span class="attr">where</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">includes</span>: &#123;</span><br><span class="line">      <span class="attr">model</span>: <span class="title class_">Food</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); <span class="comment">// 取得id=1的Recipe以及他所關聯到的食材Food</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="eager-loading-amp-lazy-loading"><a href="#eager-loading-amp-lazy-loading" class="headerlink" title="eager loading &amp; lazy loading"></a>eager loading &amp; lazy loading</h2><p>這邊會提到的是，ORM如何處理關聯的兩種概念。<br>注意，這邊強調概念是有原因的，我們後面看下去:</p>
<ul>
<li>eager loading: 一開始就透過較大的查詢取得所有內容，包括關聯資料</li>
<li>lazy loading: 僅在確實需要時才取得關聯資料</li>
</ul>
<p>會強調概念，指的是各個ORM實現這個概念的技術並不一定相同。<br>以Sequelize而言–<a href="https://demopark.github.io/sequelize-docs-Zh-CN/core-concepts/assocs.html">官方範例</a>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lazy loading</span></span><br><span class="line"><span class="keyword">const</span> awesomeCaptain = <span class="keyword">await</span> <span class="title class_">Captain</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">  <span class="attr">where</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack Sparrow&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name:&#x27;</span>, awesomeCaptain.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Skill Level:&#x27;</span>, awesomeCaptain.<span class="property">skillLevel</span>);</span><br><span class="line"><span class="comment">// getShip即為Sequelize實現lazy loading的方式，他會被自動加入Captain實例中。</span></span><br><span class="line"><span class="keyword">const</span> hisShip = <span class="keyword">await</span> awesomeCaptain.<span class="title function_">getShip</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// eager loading</span></span><br><span class="line"><span class="keyword">const</span> awesomeCaptain = <span class="keyword">await</span> <span class="title class_">Captain</span>.<span class="title function_">findOne</span>(&#123;</span><br><span class="line">  <span class="attr">where</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack Sparrow&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// include為Sequelize實現的方式</span></span><br><span class="line">  <span class="attr">include</span>: <span class="title class_">Ship</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Sequelize的實現方式:<br>lazy loading是透過他提供的getInstance()介面，多做一次query並將資料對應到之上；而eager loading，則是在搜尋的時候，就直接使用JOIN建立新的table以供搜尋。</p>
<h2 id="不一樣的實現方式"><a href="#不一樣的實現方式" class="headerlink" title="不一樣的實現方式"></a>不一樣的實現方式</h2><p>以Laravel的Eloquent而言，他在eager loading其實是採用多次query而非JOIN的方式。<br>如果將他的方式寫成SQL發生的query，大概會是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Captain <span class="keyword">WHERE</span> Captain.name <span class="operator">=</span> <span class="string">&#x27;Jack Sparrow&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Ship <span class="keyword">WHERE</span> Ship.id <span class="keyword">IN</span> [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>] <span class="comment">-- 看有幾艘船</span></span><br></pre></td></tr></table></figure>
<p>然後透過ORM把兩次query資料組合給應用程式。</p>
<p>根據了解，這樣雖然可能會相對於JOIN來的慢，但他的好處可能包括:</p>
<ul>
<li>關聯式資料庫與非關聯式資料庫的關係可以透過這樣的分離較容易實現。</li>
<li>對於Paginator有利</li>
</ul>
<p>詳情可以在閱讀參考資料～<br>我認為對於eager loading 及lazy loading是以一個概念或技術的角度去理解，並了解不同的ORM如何實現。<br>有助於我們思考如何針對情境使用更有利的方式做搜尋～</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這個單元有比較多程式碼，同時也對於eager loading 及 lazy loading在不同的ORM有不同的實現有了一些認識！<br>而且從這裡的概念也可以知道，其實無論是什麼資料庫，若資料AB間具有一對多關係，若想同時取得資料，就需要預防撰寫程式時發生N+1 problems。</p>
<p>今天就這樣啦，明天就要進到有關於API的部分囉</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/doctolib/understanding-and-fixing-n-1-query-30623109fe89">Understanding and fixing N+1 query</a><br><a href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping">What is the “N+1 selects problem” in ORM (Object-Relational Mapping)?</a><br><a href="https://stackoverflow.com/questions/23920540/why-cant-laravel-eloquent-use-join-for-eager-loading">Why can’t Laravel&#x2F;Eloquent use JOIN for Eager Loading?</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>N+1 Problems</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>db大觀園(下)-非關聯式資料庫overview及分散式設計</title>
    <url>/code-blog/2022/09/30/DB_Non_Relational/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>談到NoSQL時常有兩種說法，一種說不是SQL，一種說不僅僅是SQL，但總之，這一類的資料庫相對於SQL，不再採用昨天所說的關係表。</p>
<p>關聯式資料庫最大的特色是可以減少冗餘，除了減少儲存成本，在資料更新上也會佔到優勢。<br>不過在儲存成本大幅降低的時候開始，開始出現了已管理而非最少資料為導向的NoSQL DB。</p>
<p>除此之外，資料與資料間具有關係的關聯式資料庫在分散式系統設計上的困難也讓NoSQL冒出頭來。</p>
<p>雖然我所在的工作使用的是mongoDB，但今天也會稍稍看一下其他不同種類的DB，拓展一點視野，那就開始吧~</p>
<span id="more"></span>
<h2 id="類型"><a href="#類型" class="headerlink" title="類型"></a>類型</h2><p>以資料型態來區分，可以分為四種類型</p>
<ul>
<li>Document database</li>
<li>Key-value database</li>
<li>Wide-column store</li>
<li>Graph databases</li>
</ul>
<h3 id="Document-database"><a href="#Document-database" class="headerlink" title="Document database"></a>Document database</h3><p>資料被存在類似JSON結構的檔案中，被稱為document，每個document包含成對的值。<br>舉例像是: mongoDB<br>特色: 資料結構彈性高，且可對應開發時的資料結構。</p>
<h3 id="Key-value-database"><a href="#Key-value-database" class="headerlink" title="Key-value database"></a>Key-value database</h3><p>如名字所示，資料被表示成key及對應的value，因為通常只能用key去搜尋value，所以查詢上相對簡單，適合儲存大量、不需複雜查詢的資料，常用於cache。<br>舉例像是: redis及DynanoDB<br>特色: 查詢速度快且簡單</p>
<h3 id="Wide-column-store"><a href="#Wide-column-store" class="headerlink" title="Wide-column store"></a>Wide-column store</h3><p>資料被儲存在column family中，每個column family會儲存常被一起搜尋的資料，例如若有一個Person類別，年資跟薪水或許是被認定常被一起搜尋的內容，就會被放在一起。<br>由上可知，被儲存的資料是根據我們預先會查詢他們的方式被儲存起來的。<br>舉例像是: Cassandra、HBase<br>特色: 特定查詢效能高</p>
<h3 id="Graph-databases"><a href="#Graph-databases" class="headerlink" title="Graph databases"></a>Graph databases</h3><p>將資料以圖的方式儲存，每個資料實例都是一個節點。<br>而節點之間有一個具有方向性、可命名的連結，稱為關係。<br>這樣的資料庫常用來處理具有多層關係的數據資料，例如推薦引擎、地圖等。<br>舉例像是: Neo4j<br>特色: 以數據之間的關係作為重心，適用情境相對少。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><h3 id="初步認識"><a href="#初步認識" class="headerlink" title="初步認識"></a>初步認識</h3><p>什麼是CAP呢?</p>
<blockquote>
<p>在理論計算機科學中，CAP定理（CAP theorem），又被稱作布魯爾定理（Brewer’s theorem），它指出對於一個分布式計算系統來說，不可能同時滿足以下三點: Consistency一致性、Availability可用性、Partition tolerance分隔容忍<br>– <a href="https://zh.m.wikipedia.org/zh-tw/CAP%E5%AE%9A%E7%90%86">維基百科</a></p>
</blockquote>
<p>根據這個理論，一個資料庫在做分散式系統時，不可能同時滿足三者，你也可以稱它為魚與熊掌不可兼得理論XD<br>也因此產生下圖說明這件事情</p>
<p><img src="https://i.imgur.com/dYbstCB.png" alt="圖 4">  </p>
<p>稍微解釋一下三者</p>
<ul>
<li>Consistency一致性<blockquote>
<p>all nodes see the same data at the same time</p>
</blockquote>
</li>
</ul>
<p>如果把多個資料中的各個單台稱為節點好了，一致性指的是每個節點都拿的到最新的資料。</p>
<ul>
<li>Availability 可用性<blockquote>
<p>a guarantee that every request receives a response about whether it was successful or failed</p>
</blockquote>
</li>
</ul>
<p>意思是指所有對資料庫的請求都能得到回應，也就是服務持續可用</p>
<ul>
<li>Partition Tolerance分區容錯性<blockquote>
<p>the system continues to operate despite arbitrary message loss or failure of part of the system</p>
</blockquote>
</li>
</ul>
<p>分散式系統的部分因為機器或是網路問題無法運作時，其餘系統仍能提供完整的服務</p>
<h3 id="CAP與NoSQL"><a href="#CAP與NoSQL" class="headerlink" title="CAP與NoSQL"></a>CAP與NoSQL</h3><p>在查到許多資料的時候，常把CAP與NoSQL一起談，但我一直很困惑為什麼一個談分散式資料庫的理論和NoSQL有什麼很強的關聯嗎?<br>後來想想，這大概跟NoSQL的一個特性有關-資料間的關聯性弱或沒有，在這樣的狀況下，當資料規模變很大的時候，我可以直接增加機器去接受請求，這樣的方式稱做水平擴展。<br>事實上，SQL本身也是可以討論CAP，正如上圖所言，他會落在CA這區，犧牲了分區容錯性。</p>
<p>但因為剛剛提到的平行擴展，也就是增加多台DB必定無法容忍分區容錯性的問題，也代表SQL相對難以水平擴展。<br>而NoSQL通常都適宜水平擴展，也就是符合CP、或是AP的狀況。</p>
<p>這兩個狀況其實就代表使用情境的選擇，畢竟，適合的才是最好的~</p>
<ul>
<li><p>AP<br>重視可用性，也代表犧牲了強一致性，意思是指，雖然每次請求資料庫都會有結果，但資料拿到手有可能不是最新的。</p>
</li>
<li><p>CP<br>重視強一致性，也代表犧牲了可用性，剛好和上方顛倒。</p>
</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過了解NoSQL的出現，對於整個開發的發展也可以看到，在各場景適用各自適合的方法的論述變得越來越明顯。<br>而且蠻有趣的，這些概念也都會對於未來需要判斷如何決策帶來重要的影響，雖然淺淺的，但也算是開頭了吧~~</p>
<p>明天會來看一下關聯式資料庫的一個重要特性-ACID及和此相關的Transactions。</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10256528">[淺談]-NoSQL資料庫怎麼選？</a><br><a href="https://ithelp.ithome.com.tw/articles/10256528">學了那麼多 NoSQL 資料庫 NoSQL 究竟是啥</a><br><a href="https://oldmo860617.medium.com/%E5%88%9D%E6%AD%A5%E8%AA%8D%E8%AD%98%E5%88%86%E6%95%A3%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87-nosql-cap-%E7%90%86%E8%AB%96-a02d377938d1">初步認識分散式資料庫與 NoSQL CAP 理論</a><br><a href="https://www.julianbrowne.com/article/brewers-cap-theorem">Brewer’s CAP Theorem</a><br><a href="https://www.twblogs.net/a/5b8c64a82b7177188332865e">學習分佈式不得不會的CAP理論</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>DBMS</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>db大觀園(上)-關聯式資料庫overview</title>
    <url>/code-blog/2022/09/29/DB_Relational/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>開始進入DB的範圍，DB目前分兩類，SQL及No SQL，No SQL並不真的算是一種種類，他比較算是集合，所以兩者的意思說起來應該是:</p>
<blockquote>
<p>SQL DB跟那些不是SQL的DB</p>
</blockquote>
<p>SQL也就是今天要聊的relational DB到底有什麼了不起的地方，竟然讓除了他以外的DB都被分成一類。<br>這就是好像有天有人跟你說，這世界上的飲料只分成烏弄跟不是烏弄得一樣XD</p>
<p>另外其實SQL裡面也分了很多不同的DB，那他們有什麼樣相同的特性，讓他們既是不同的DB卻被通稱為SQL DB呢?<br>我們今天也會稍微看看他們彼此的特色~</p>
<span id="more"></span>

<h2 id="什麼是關聯式資料庫relational-db-RDB"><a href="#什麼是關聯式資料庫relational-db-RDB" class="headerlink" title="什麼是關聯式資料庫relational db(RDB)?"></a>什麼是關聯式資料庫relational db(RDB)?</h2><blockquote>
<p>關聯資料庫 (RDB) 是在資料表、資料列和資料欄中建構資訊的方式。RDB 可透過彙整資料表來建立資訊之間的關聯或關係，以便輕鬆瞭解各資料點之間的關係並取得深入分析。<br>– <a href="https://cloud.google.com/learn/what-is-a-relational-database">Google</a></p>
</blockquote>
<p>relational db將資料整合成行row跟欄column，多個row會集合成一個表table，多個table就會組成一個db。<br>table通常都會設定一個主鍵primary key(PK)的欄位代表該row，就好像一個大學裡面的學號一樣，每個人都不會重複。<br>table之間在需要存在類似資料時會以其他table的PK作為代表，稱為外鍵foreign key(FK)，就好比今天有入學文件，文件有文件的編號，文件上會寫著學生的學號。<br>透過PK和FK可以表現table之間的關係，以剛剛舉例，一個學生可能同時有很多份文件，每分文件只屬於一個學生，那學生與文件的關係就是一對多。</p>
<p>通常關聯式資料庫也代表他具有交易(事務)特性，具有這樣的特性代表他可以具有一個最小的執行單位稱為「交易」(Transaction)，在這個交易可能包含多個對資料庫操作的行為，並且這個交易是全有全無的。</p>
<p>另外relational db manager system(RDBMS)指的是管理RDB的系統，可以把他理解成是RDB的介面~</p>
<h2 id="什麼是SQL"><a href="#什麼是SQL" class="headerlink" title="什麼是SQL?"></a>什麼是SQL?</h2><p>SQL全名叫做結構話查詢語言Structured Query Language，專門用來與關聯式資料庫溝通的程式語言。<br>也正因為這樣，所以關聯式資料庫也常被稱為SQL資料庫。</p>
<p>而前面曾經說到SQL其實還有很多細微分支，但因為他們也是以RDB的概念管理資料，並且都能使用SQL和RDBMS溝通，所以也都被稱為SQL DB。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>原本是想要做一些對於DB的比較，但後來發現，能夠做出比較，已經是對該DB有不少研究或是已經有相關經驗。<br>所以那部分就沈船了。</p>
<p>但多少有點收穫是，發現一個常被拿來做效能量化數據的單位稱為TPC，他們有許多不同情境的測試，是一個值得作為參考的數據來源。<br>另外也發現，常會拿來比較的一些項目包括: 成本(學習、費用)、效能、安全性、擴充性。<br>不過針對效能這點，以別人做得比較來看，與其說誰最好，不如說誰相對最好會來的更準確一些。</p>
<p>最後就提供一些我找到的比較文章僅做紀念吧。</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10206222">[Day15] 資料庫 - 介紹與比較</a></li>
<li><a href="http://caryhsu.blogspot.com/2011/06/sql-server-vs-oracle-and-mysql.html">不同資料庫的比較 - SQL Server vs Oracle and MySQL</a></li>
<li><a href="https://faq.postgresql.tw/postgresql-vs-mysql-vs-sql-server-vs-oracle">PostgreSQL vs MySQL vs SQL Server vs Oracle</a></li>
</ul>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.ibm.com/cloud/learn/relational-databases">Relational Databases</a><br><a href="https://oldmo860617.medium.com/database-transaction-acid-156a3b75845e">Database Transaction &amp; ACID</a><br><a href="https://www.edx.org/course/databases-5-sql">Databases: Relational Databases and SQL</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>RDBMS</tag>
        <tag>RDB</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>瀏覽器(Browser)與他們的產地-瀏覽器是怎麼運作的?</title>
    <url>/code-blog/2022/09/18/Network_Browser/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這邊將提及的是，當我們在瀏覽器的搜尋欄中輸入一串網址<code>https://ithelp.ithome.com.tw/</code>時，在瀏覽器的背後到底發生了什麼事情?</p>
<p>稍稍了解這個部分，對於開發者在開發符合使用者需求的網站-快速渲染網頁、交互溝通順暢，是會帶來幫助的；甚至當網頁出現問題或效率不彰的時候，透過對於瀏覽器運作機制的了解，也能對糾錯帶來一定的幫助。</p>
<p>不過因為這邊主要側重後端的角度上，瀏覽器溝通的前面步驟導航其實就是典型的HTTP溝通，也是後端常會接觸到的範圍，所以這部分會多些篇幅，而在解析、渲染的部分等關於畫面的部分就會說得相對少很多XD。</p>
<p>那就開始今天的部分吧!!</p>
<span id="more"></span>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>透過MDN的分類，可以將這段流程分為以下幾段</p>
<ol>
<li>導航Navigation: 建立與Server連線</li>
<li>回應Response: 發出請求並得到回應</li>
<li>解析Parsing: 解析回應</li>
<li>渲染Render: 渲染畫面</li>
<li>交互Interactivity: 與使用者互動</li>
</ol>
<h2 id="導航"><a href="#導航" class="headerlink" title="導航"></a>導航</h2><p>此部分將完成的工作是透過傳輸層與Server建立連線。</p>
<p>這部份我們會先以HTTP&#x2F;2.0之前作為範例，在前一天已經有提到過HTTP&#x2F;3會使用不同的傳輸層協定，有興趣可以再回頭看一下。</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10292700">超文本傳輸協定(HTTP)是什麼?</a></li>
</ul>
<h3 id="網域名稱系統Domain-Name-System-DNS"><a href="#網域名稱系統Domain-Name-System-DNS" class="headerlink" title="網域名稱系統Domain Name System(DNS)"></a>網域名稱系統Domain Name System(DNS)</h3><p>在瀏覽器與OS溝通完畢要進行與目標網址的對話後，第一步要做的就是與DNS溝通取得正確ip位置，在談及DNS時，我們稍微談一下網址，並以<code>https://ithelp.ithome.com.tw/</code>作為範例，網址結構上分為:</p>
<ol>
<li>傳輸協定Protocol: <code>https://</code></li>
<li>主機&#x2F;網域Host&#x2F;Domain: <code>ithelp.ithome.com.tw</code></li>
<li>路徑Path: <code>/</code></li>
</ol>
<p>接著，我們目前僅需要知道的部分是，目前可讀的網域其實僅是一種對照，他會被對照到一個真實的ip，好處包括彈性(可以隨意變換Domain背後的ip)、易讀易記等。</p>
<p>而要怎麼透過Domain去找到真實的ip，這個就是DNS工作的範疇了，詳情我就不解釋，這是明天的主題XD</p>
<h3 id="TCP連線"><a href="#TCP連線" class="headerlink" title="TCP連線"></a>TCP連線</h3><p>在得知ip位置之後，會進行經典的TCP三次握手(TCP 3-way Handshake)，其目的是為了確保連接的正確性，包含SYN, SYN-ACK, ACK。</p>
<p>A及B分別代表Client及Server, 而三次握手分別完成的工作包括有:</p>
<ol>
<li>同步Sync: 由A發出，讓Server知道我們的TCP設置。</li>
<li>同步確認Sync Check: 由B發出，回應Client他已經收到訊息並準備建立連線進行通信。</li>
<li>確認Check: 由A再度發出，表示完成連線。</li>
</ol>
<p>在這裡我當時自問了一個有趣的小問題: 為什麼需要第三次確認才算建立連線呢?<br>這邊找到了一個解釋: </p>
<blockquote>
<p>一句話，主要防止已經失效的連接請求報文突然又傳送到了服務器，從而產生錯誤。 – <a href="https://blog.csdn.net/qzcsu/article/details/72861891">兩張動圖-徹底明白TCP的三次握手與四次揮手</a><br>————————————————<br>版权声明：本文为CSDN博主「小书go」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
</blockquote>
<p>他的原意是為了避免產生錯誤且不必要的連結，假設是二次握手好了: </p>
<ol>
<li>比如連接X請求SYN送出，雖沒丟失但因為某些原因被延誤。</li>
<li>A因為遲遲沒收到SYN-ACK誤以為連接請求丟失就重發連接請求Y。</li>
<li>重發後完成二次握手，在完成request-response後關閉連線。</li>
<li>此時連接請求X總算到了B，B發回SYN-ACK</li>
<li>A在收到訊息後就又建立了新的連線了。</li>
</ol>
<p>作為旁觀者的我們知道這個步驟5的連接其實是不必要的損耗，為了避免這個損耗，於是就出現了三次握手，我們回到原本的過程5。</p>
<ol start="5">
<li>此時SYN-ACK回到A，A這邊有資訊知道這個連接是不用被建立的，就不會再回傳一次ACK給B</li>
<li>B在收不到ACK的狀況下，就也可以知道這個連接是不用被建立的。</li>
</ol>
<h3 id="SSL-x2F-TLS握手"><a href="#SSL-x2F-TLS握手" class="headerlink" title="SSL&#x2F;TLS握手"></a>SSL&#x2F;TLS握手</h3><p>基於安全的需求，在TCP之上又多出了一層SSL&#x2F;TLS安全協定，於是當我們使用HTTPS的網址時就會多出這段過程，其目的在於讓端點雙方溝通的訊息僅能被彼此看懂，這也會在後面的鐵人賽在多加敘述XD。</p>
<h2 id="回應Response"><a href="#回應Response" class="headerlink" title="回應Response"></a>回應Response</h2><p>總算完成連接之後，就會開始進行HTTP的Request-Response過程，輸入在網址欄的網址，會作為GET請求被發出，更準確來說，瀏覽器會替你發出一條HTTP報文並請求Server回覆。</p>
<h2 id="解析Parsing、渲染Render、交互性Interactivity"><a href="#解析Parsing、渲染Render、交互性Interactivity" class="headerlink" title="解析Parsing、渲染Render、交互性Interactivity"></a>解析Parsing、渲染Render、交互性Interactivity</h2><p>在收到<code>https://ithelp.ithome.com.tw</code>回應的網頁資料之後，接著就是開始將資料做解析。<br>其過程根據不同的瀏覽器，有不同的渲染引擎，像是Chrome使用的是開源引擎WebKit的分支Blink，FireFox使用的則是Gecko，解析的流程略有不同，但概念的大方向其實是接近的。</p>
<ol>
<li>將HTML轉換成DOM tree，CSS轉換成CSSOM tree</li>
<li>將兩者計算並建立Render Tree</li>
<li>Layout過程，為每個Render tree的節點決定在螢幕上的確切座標</li>
<li>遍歷Render Tree的節點，使用UI後端繪製畫面。</li>
</ol>
<p>在完成畫面繪製後，畫面就可以與使用者互動了。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>還有好些地方可以深入研究，包括解析、渲染、交互之後的TCP關閉連線，甚至是HTTP&#x2F;3的QUIC連線都有深入可以理解的部分。</p>
<p>不過透過對於這些內容的理解究竟可以做些什麼呢?</p>
<p>來舉一些例子好了，從比較底層的來看，當我們知道SSL&#x2F;TLS是作為安全性的增強而產生的協議，並且知道他產生了多次的RTT(封包往返時間)，如果未來網頁溝通效率很遭，有可能可以以此猜測瓶頸出現在哪。</p>
<p>另外一個比較實際的角度，我們的網頁有可能突然掛掉，並收到伺服器回饋表示DNS parsing fail，這時候或許就不是一籌莫展，我們因為知道DNS僅代表ip的映射，若有些重大服務&#x2F;第三方服務，在考量之下也可以請對方先以真實ip代替迴避重大損失。</p>
<p>大概就是這樣囉，明天我們會稍稍深入DNS，了解到我們的DN是怎麼被映射回ip的，明天見~</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://web.dev/howbrowserswork/">How Browsers Work</a><br><a href="https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/">Traffic example</a><br><a href="https://bbs.huaweicloud.com/blogs/314817">TCP壅塞控制機制</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work">MDN-How_browsers_work</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>自己家的地址自己取-網域(domain) v.s. 網域名稱系統(domain name system)</title>
    <url>/code-blog/2022/09/19/Network_DNS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>域名讓網頁的ip地址轉變成能夠被人類理解的內容，根據維基百科的資料，到2022年已經有超過5億的域名登記註冊。</p>
<p>今天要稍微深入看一下Domain name這個部分的內容，內容應該會包含域名的結構、域名系統(DNS)如何在client要求與建立連線時將正確的ip交付。</p>
<span id="more"></span>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>可理解性: 比IP位置更好被記億。</li>
<li>唯一性: 和IP位置一樣，域名也是唯一性的，同一個域名不會代表兩個不同的IP位置，另外，因為他是映射的IP位置可以被更改，你可以隨意修改你的DN對應到的服務器IP位置。</li>
</ol>
<h2 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h2><p>一個域名可以由好幾個字串組成，這些字串被點(.)分隔，而最右邊的字串被稱為頂級域名Top-Level Domain(TLD)。</p>
<p>頂級域名可以大致分為國家和地區頂級域(ccTLD)以及通用頂級域(gTLD)，ccTLD就像是台灣的tw結尾，而gTLD通常具有特定意義代表多個組織，例如gov(政府)、edu(教育機構)、com(商業)…等等</p>
<p>頂級域名往左就會被稱為子域名，由二級開始，每向左多出一個域名就會下降一層，三級、四級…等等。</p>
<h2 id="DNS機制"><a href="#DNS機制" class="headerlink" title="DNS機制"></a>DNS機制</h2><p>我們稍稍回到昨天，當我們輸入網址並按下ENTER後，在透過DNS取得正確的步驟包括以下:</p>
<ol>
<li>檢查本機的DNS緩存是否有保存IP位置。</li>
<li>假設並沒有緩存，現在要開始做DNS查詢。</li>
<li>DNS查詢首先會往此電腦被設定的DNS伺服器去查詢，我們在此處稱為本地伺服器。</li>
<li>若是符合該主機的本域名會直接回答，沒有的話也會檢查Cache看有沒有相關資料。</li>
<li>若依舊沒有的狀況，此本地DNS server會向此server有紀錄的根網域主機root domain name server(保管所有TLDNS的伺服器位置資料)發出請求。</li>
<li>該根網域主機會回傳一台控制該網域的DNS的ip位置。</li>
<li>在得到新的DNS IP後，本地DNS會向該DNS發出請求。</li>
<li>若並非為該DNS儲存的資料，則會回傳更靠近該網域的DNS server。</li>
<li>重複7, 8步驟直到收到正確ip為止</li>
</ol>
<p>從以上資訊我們可以得到一個結論是一台DNS並不會存放所有域名的DN資料，資料都是分別儲存在層層搜尋出來的。</p>
<p>唯一共用位置資料的只有前面提到的根網域伺服器，他們共用同一份根域(Root Zone file)檔案，裡面記錄著頂級域名權威伺服器的ip位置。</p>
<h2 id="有趣的小指令-whois"><a href="#有趣的小指令-whois" class="headerlink" title="有趣的小指令: whois"></a>有趣的小指令: whois</h2><p>linux的系統可以透過apt install whois安裝這個命令。</p>
<p>這個命令可以讓你查看指定網域的註冊資料，你也可以知道你查詢的網域是不是已經被使用了。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>還記得過往曾經看過一些文章和你說，修改DNS的位置可以加速你的網路讀取速度，現在想想，他的邏輯應該是，若你可以直接在第一層詢問local DNS就拿到你要的ip位置，就可以少等待很多時間。</p>
<p><img src="https://i.imgur.com/L6EtBWC.png" alt="windows DNS設定修改"></p>
<p>但換個方式來說，你的server或是你的電腦為了效率，其實也會將取得的IP做Cache，所以第二次連接相同網站速度還是無法提升時，也代表或許瓶頸並不是出現在DNS這段，對於排錯又可以多一些額外的資訊了。</p>
<p>今天差不多就到這裡囉，明天會聊聊託管(hoisting)</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_domain_name">MDN-Domain</a><br><a href="https://www.homenethowto.com/advanced-topics/traffic-example-the-full-picture/">Traffic</a><br><a href="https://blog.twnic.tw/wp-content/uploads/2021/08/2021_jprs_ZH-TW_0830_final.pdf">網路大冒險</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>說只有對方聽得懂的話-HTTPS &amp; SSL &amp; TLS</title>
    <url>/code-blog/2022/10/07/Network_Https/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前曾經談過關於Internet Protocol Suite(IPS)，提到過Web中的各個網站就是HTTP的應用，又提到過IPS可以以四層來理解:</p>
<ol>
<li>應用(application): HTTP</li>
<li>傳輸(transport): TCP</li>
<li>網路互連(internet): IP</li>
<li>網路存取(Network Access (link))。</li>
</ol>
<p>但我們都曾經在瀏覽器上的網址欄看到https開頭的網址<br><img src="https://i.imgur.com/yofUKox.png" alt="圖 12">  </p>
<p>這樣，https又是什麼呢?</p>
<p>那就來了解一下吧</p>
<span id="more"></span>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS全名為超文本傳輸安全協定HyperText Transfer Protocol Secure，還記得昨天提到過的加密嗎?<br>其實HTTPS就是指將要傳輸的資料經過加密傳輸出去再讓對方解密獲得資訊，以確保資料僅能被傳輸的雙方知道的一種協定。</p>
<h2 id="SSL-amp-TLS"><a href="#SSL-amp-TLS" class="headerlink" title="SSL &amp; TLS"></a>SSL &amp; TLS</h2><p>全名分別是安全通訊協定Secure Sockets Layer(SSL)及傳輸層安全性協定Transport Layer Security(TLS)，這兩個協定的目的就是為了讓HTTP之間的通訊可以安全，且避免被竊聽。<br>SSL是比較早期的協定，後來由TLS取代~</p>
<p>他的工作層的位置如圖<br><img src="https://i.imgur.com/nsPnWjP.png" alt="圖 14">  </p>
<p>他的工作主要包括兩個:</p>
<ul>
<li>通訊驗證: 驗證證書以確認網站身分</li>
<li>資訊加解密: 對資料使用對稱加密</li>
</ul>
<h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><p>要了解HTTPS如何工作以及為何要這樣做，我們需要對加密如何在對話兩端如何被應用、可能會發生什麼問題、如何改進逐步討論。</p>
<h3 id="對稱加密"><a href="#對稱加密" class="headerlink" title="對稱加密"></a>對稱加密</h3><p>最單純的事情就是，我們共享一個密碼就好了~<br>而對稱加密就是指兩方都使用相同的密碼來作加解密。</p>
<ul>
<li><p>問題:<br>不管是由誰產生密碼，為了將密碼交給對方好讓對方解密，為了方便性就不得不經過網路。<br>只要會經過網路就有封包被劫持的風險，所以我只要劫持到某次封包裡包含著密碼，那我就發了XD</p>
</li>
<li><p>解決方案:<br>於是出現了非對稱加密~</p>
</li>
</ul>
<h3 id="非對稱加密"><a href="#非對稱加密" class="headerlink" title="非對稱加密"></a>非對稱加密</h3><p>既然共用的密碼會被劫持，那就不要讓密碼共用就好啦。<br>後面出現了一種加密用A密碼，稱謂公鑰；解密用B密碼稱為私鑰的做法。</p>
<p>於是Server決定產出A1公鑰及A2私鑰，他將公鑰透過網路傳輸給Client(Browser)。<br>這樣Client就可以將資料用公鑰加密，然後Server用從來沒外流過的私鑰解密，而就算公鑰被劫持，但因為他沒有私鑰，他也沒辦法解密了。</p>
<p>這樣Client &#x3D;&gt; Server的單向傳輸安全了，那雙向呢?<br>ok，那Client也製作一個公私鑰，讓Server &#x3D;&gt; Client 也安全呢?</p>
<ul>
<li><p>問題:<br>看起來是可行的，但除了考量安全還得考量效能。<br>HTTP想要傳輸的資料可能會很龐大，而非對稱加密其實很費時，所以對於頻繁溝通且資料可能龐大的HTTP來說並不有利。</p>
</li>
<li><p>解決方案:<br>原本不使用對稱加密是因為網路不安全，密碼會在傳輸過程中被盜走。<br>那如果在安全的環境下分享密碼呢?</p>
</li>
</ul>
<p>沒錯，我們應用剛剛提到的非對稱加密製造安全的傳輸環境來傳輸對稱加密用的密碼!</p>
<h3 id="非對稱-對稱"><a href="#非對稱-對稱" class="headerlink" title="非對稱 + 對稱"></a>非對稱 + 對稱</h3><p>我覺得當初想到這個人很聰明XD</p>
<p>狀況現在就變成</p>
<ol>
<li>在經過連線建立後</li>
<li>Server製造公私鑰p1及s1，並將公鑰p1交給Client</li>
<li>Client用公鑰p1加密密碼(對稱加密用)，並把加密後的資料傳回Server</li>
<li>Server收到後用私鑰s1解密</li>
<li>之後兩方都用對稱加密來加解密資料</li>
</ol>
<p>這樣是不是就完美了!!!!</p>
<ul>
<li>問題:<br>HTTPS確實採用類似這樣的方案，但這會出現一個問題: 中間人攻擊。</li>
</ul>
<p>什麼是中間人攻擊呢?中間人就是指在Server和Client之間多了一個人，作為兩者之間的轉發。<br>模擬一下他會做的事情:</p>
<ol>
<li>在經過連線建立後</li>
<li>Server製造公私鑰p1及s1，並將公鑰嘗試交給Client</li>
<li><strong>中間人攔截p1，並將自己製作的公鑰p2轉發給Client</strong></li>
<li>Client用公鑰p2加密密碼(對稱加密用)，並把加密後的資料嘗試傳回Server</li>
<li><strong>中間人攔截，加資料用自己的私鑰s2解密(取得共用密碼)，並將Client資料用p1加密後傳回Server</strong></li>
<li>Server收到後用私鑰s1解密</li>
<li>之後兩方都用對稱加密來加解密資料</li>
</ol>
<p>中間人就這樣開心拿資料，然後Client-Server都沒發現其實拿到的資料有問題。</p>
<p>我們從上帝視角看，知道你明明就拿錯公鑰了，但問題就出在:<br>Client並不知道他拿到的公鑰是誰的，他只知道是一串無意義的資料~</p>
<ul>
<li>解決方案:<br>交給別人證明這個公鑰是真的，也就是現在的證書系統。</li>
</ul>
<h3 id="憑證"><a href="#憑證" class="headerlink" title="憑證"></a>憑證</h3><p>打開Chrome，點開網址左邊的那個鎖，如果你也是使用HTTPS的連線，一定會看到跟憑證有關的資訊。<br><img src="https://i.imgur.com/CCdeSS8.png" alt="圖 15">  </p>
<p><strong>那這樣憑證是怎麼運作的?</strong></p>
<p>他的核心就跟學校頒發畢業證書一樣，大家相信這些學校，所以相信他們頒發的證書；也有一個概念相同的機構在頒發這些證書。</p>
<p>Server會將他的證書傳給Client，裡面會包含Server的相關資訊以及最重要的公鑰。</p>
<p><strong>要怎麼不被假冒跟修改?</strong></p>
<p>不過這樣似乎沒有解決原本的問題，就算有資訊，中間人還是可以竄改後再傳給Client。</p>
<p>所以在Client的通訊加密層TLS還有一個任務就是要向權威機構確認這個證書到底是不是真的。</p>
<p><strong>如何確認?</strong></p>
<p>第一件事情: Server需要向權威機構申請證書，而權威機構這邊也會產生公私鑰，公鑰一樣發出去給大家，但機構會將資料先做雜湊再用私鑰加密(非對稱加密)。</p>
<p>第二件事情: TLS在收到證書時，會拿到兩項重要的東西</p>
<ul>
<li>加密後的雜湊值: 簽章signature</li>
<li>證書內容: 包含雜湊演算法</li>
</ul>
<p>他會把這兩項經過處理後去比對看是否相同，相同就ok，不相同就中斷連線</p>
<ol>
<li>把證書內容用證書上的雜湊演算法做出雜湊值hash1</li>
<li>把簽章用公鑰解密得到hash2</li>
</ol>
<p>防止中間人的關鍵在2這段</p>
<ol>
<li>如果想要改證書內容: 但因為他沒有私鑰，所以就算他重新雜湊並加密，Client端會用權威機構的公鑰解密，會因此與證書內容的雜湊值相異。</li>
<li>直接抽換成一個合格的證書: 因為這樣就不能更換內容，Client端比對他原本想要request的資料跟證書內容不相符也會直接失敗。</li>
</ol>
<p><strong>我們來當駭客看看</strong></p>
<p>那這樣真的沒辦法騙過嗎?</p>
<p>我想了一陣子，前面提到的關鍵是權威機構握有只有他才知道的私鑰。<br>而有了對於證書的非對稱加密才會無法騙過，所以我想到的方法只有:</p>
<ol>
<li>成為Server跟權威機構的中間人，讓Client取得的公鑰也是中間人的公鑰，這樣就可以直接抽換證書內容了XD</li>
</ol>
<p>也不知道對不對，不過這部份我們就不再深究了哈哈</p>
<h2 id="流程總結"><a href="#流程總結" class="headerlink" title="流程總結"></a>流程總結</h2><p><img src="https://i.imgur.com/hETv3Qm.png" alt="圖 13">  </p>
<blockquote>
<p>– <a href="https://zhuanlan.zhihu.com/p/96494976">你知道，HTTPS用的是对称加密还是非对称加密？</a></p>
</blockquote>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上圖做為總結就很足夠了，感謝製圖的大大，惠我良多~</p>
<p>所以HTTPS其實是非對稱及對稱加密的結合，權威機構製作證書時做非對稱加密，傳輸時憑藉證書做對稱加密。<br>這樣的好處還蠻多的，除了安全性外，非對稱加密的時間成本在還沒傳輸前就解決了!</p>
<p>今天又是有收穫的一天，明天見~</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://tw.alphacamp.co/blog/http-https-difference">一文搞懂 HTTP 和 HTTPS 是什麼？兩者有什麼差別</a><br><a href="https://www.readfog.com/a/1638923950567297024">終於有人把 HTTPS 原理講清楚了！</a><br><a href="https://zhuanlan.zhihu.com/p/96494976">你知道，HTTPS用的是对称加密还是非对称加密？</a><br><a href="https://blog.51cto.com/u_15290941/3047577">HTTPS(一) – 基础知识（密钥、对称加密、非对称加密、数字签名、数字证书）</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>欸黑，我的主機不在我家-託管(hosting)</title>
    <url>/code-blog/2022/09/19/Network_hosting/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前幾天的主題大概已經描述一個輪廓Web: 一般而言我們使用瀏覽器作為client，透過HTTP，去與一台一個具有特定ip位置的server用GET方法取得網頁內容，並透過瀏覽器引擎渲染出網頁的畫面。</p>
<p>這邊我們用一個問題代入今天的主題: server都被放在哪裡?</p>
<p>事實上具有運算、儲存的設備都可以作為主機使用，但管理一台主機的成本還蠻高的，包括能源、維護甚至是因為流量變大而有的擴充需求。</p>
<p>所以出現了Hosting服務，也就是今天的主題，通常具有較大型的主機，也有專門的人進行維護，一般來說成本相對個人管理來的低，而這些託管商則透過規模化來減少成本獲取利潤。</p>
<p>今天會大概介紹託管的分類並舉一些對應的例子。</p>
<span id="more"></span>

<h2 id="分類"><a href="#分類" class="headerlink" title="分類"></a>分類</h2><p>常見的Hosting分類包括有:</p>
<ol>
<li>共享主機 shared hosting</li>
<li>虛擬專用伺服器 VPS hosting</li>
<li>專用主機 dedicated hosting</li>
<li>雲託管 cloud hosting</li>
</ol>
<p>前三者大部分的Hosting服務商都有提供，僅最後一個服務，受限於規模及技術，僅少數服務像是AWS, GCP, Azure</p>
<p>若讓我將Hosting各個類別做成雷達圖，它包含的取向包括: 資源隔離度、維運成本、單位費用。</p>
<p><img src="https://i.imgur.com/PkuEsMS.png"></p>
<p>那接下來我們就透過雷達圖一一來看一下不同的hosting模式及特性。<br>打個預防針，這裡的數字只是比較性的，有利用我們理解各個服務的差異而已XD</p>
<h2 id="共享主機-shared-hosting"><a href="#共享主機-shared-hosting" class="headerlink" title="共享主機 shared hosting"></a>共享主機 shared hosting</h2><ul>
<li>資源隔離度: 1</li>
<li>維運成本: 1</li>
<li>租借費用: 1</li>
<li>風險: 5</li>
<li>擴充性: 1</li>
</ul>
<p>共享主機指的是共享一台物理主機的所有資源，此處的資源包括網路、CPU、記憶體，雖然大部分會設定資源使用的最高限制，但不包括最低限制，常會發生「超賣」的狀況，意思是指，我們如果將該台物理主機上所有的網站的最高限制加起來會超過該台機器所能承擔的物理上限。</p>
<h3 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h3><p>這也是為什麼他那麼便宜，因為他的訂價本身就鎖定了一些資源消耗極低的網站的客戶，並且使用一些平衡資源使用的機制確保這樣的狀況不常發生。</p>
<p>二來通常這樣的服務提供全託管，除了上傳你的網站文件外不用再做額外的維運。</p>
<h3 id="壞處"><a href="#壞處" class="headerlink" title="壞處"></a>壞處</h3><p>但會產生的風險也顯而易見，當遇到小概率事件，比如網站的總資源占用已經達到了上限時，我們架設在上面的網站也會被影響。</p>
<p>另外他的擴充性幾乎可以無視，因為你的擴充還是受限於該物理主機的整體用量，若遇到大流量時還是會受到其他人的影響</p>
<h2 id="虛擬專用伺服器-VPS"><a href="#虛擬專用伺服器-VPS" class="headerlink" title="虛擬專用伺服器 VPS"></a>虛擬專用伺服器 VPS</h2><ul>
<li>資源隔離度: 3</li>
<li>維運成本: 2</li>
<li>租借費用: 3</li>
<li>風險: 4</li>
<li>擴充性: 3</li>
</ul>
<p>虛擬專用主機和Shared Hosting一樣共享一台主機的資源，但差別在於，你對於你所能用的資源掌握的是下限，代表你能夠擁有保證不會被奪走的資源。</p>
<h2 id="好處-1"><a href="#好處-1" class="headerlink" title="好處"></a>好處</h2><p>透過確保資源的獨佔，你可以避免前面提到的相關問題: 共同資源被占用導致的限制。</p>
<p>另外你的技術彈性又更高了一些，可以多做一些客制化的設定。</p>
<h2 id="壞處-1"><a href="#壞處-1" class="headerlink" title="壞處"></a>壞處</h2><p>前面提到的客制化設定見仁見智，因為通常這也代表需要維運的部分變多了。<br>於是也出現了一些服務是讓你去購買VPS，而他負責為你維運，像是cloudway。</p>
<p>另外因為還是共享著同一台物理主機，如果有其他在同一物理主機的網站遭到攻擊，導致你所在的主機遭受到系統級的損害，一樣會對你的網站造成傷害。</p>
<h2 id="專用主機-dedicated"><a href="#專用主機-dedicated" class="headerlink" title="專用主機 dedicated"></a>專用主機 dedicated</h2><ul>
<li>資源隔離度: 5</li>
<li>維運成本: 4</li>
<li>租借費用: 5</li>
<li>風險: 3</li>
<li>擴充性: 2</li>
</ul>
<p>顧名思義，你擁有一台物理主機的全部資源，基本上可以視為一台請服務商幫你維運硬體層面的主機了。</p>
<h3 id="好處-2"><a href="#好處-2" class="headerlink" title="好處"></a>好處</h3><p>前面提到的系統級風險再次降低。<br>通常可以取得root access，等同你擁有一台雲端主機，高客製化。</p>
<h3 id="壞處-2"><a href="#壞處-2" class="headerlink" title="壞處"></a>壞處</h3><p>很貴，且軟體維運幾乎也都仰賴用戶自行處理，維運成本也高，除非是公司有資安需要硬體級別的隔離，不然很難找到理由需要使用這樣子的服務。</p>
<p>另外擴充上也會在物理主機達到極限時出現明顯的瓶頸，需要進行硬體擴充，但因為相較於VPS，通常這也同樣是VPS的極限，所以我姑且給了他擴充性2的評分，比VPS略低，但也不是說他的上限就比VPS多多少就是了。</p>
<h2 id="雲-cloud"><a href="#雲-cloud" class="headerlink" title="雲 cloud"></a>雲 cloud</h2><ul>
<li>資源隔離度: 4</li>
<li>維運成本: 5</li>
<li>租借費用: 4</li>
<li>風險: 2</li>
<li>擴充性: 5</li>
</ul>
<p>Cloud hosting與前面的服務最大的差別在於你所購買的主機的部署方式並非在單個物理主機上，而是多個物理主機組成的虛擬化大型主機之上。</p>
<h3 id="好處-3"><a href="#好處-3" class="headerlink" title="好處"></a>好處</h3><p>可以想像你的服務器架設在超大型主機之上，於是你的服務所需資源的擴充性是相當大的，另外，租借成本通常來說，是根據你的用量來決定你的費用，這句話有時候很含糊，需要根據不同雲服務的服務商來計算費用。</p>
<p>另外關於風險，以AWS為例，資源分成由大至小分為Zone、AZ(Available Zone)，最佳實踐提到你可以至少在AZ部署多個server避免AZ級的損失，或甚至在不同Zone部署server避免Zone級的損失，當然費用也會往上，端看對於server停止服務的重要性來做判斷。</p>
<h3 id="壞處-3"><a href="#壞處-3" class="headerlink" title="壞處"></a>壞處</h3><p>相對於專用伺服器來說，資源隔離度下降，可以說是對安全的部分妥協。<br>另外的，與專用伺服器相同的是維運成本及server設置也都是相對高的。</p>
<p>另外他的費用來說其實也是不低的，若需要大量的資源，也會是每個月的巨額開支。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>了解Hosting的需求對於營運及提供技術建議帶來幫助，不過對於開發本身的幫助似乎就不是特別大了XD</p>
<p>以目前的經驗來看，若是商業需要，通常會至少選擇VPS作為託管，不過目前最流行應該是雲服務吧，不只提供了託管服務，還能夠透過他本身提供的其他雲服務做串接，像是靜態儲存、MQ、LB等，也減少了公司成長前期在維運上所需要花費的成本。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=AXVZYzw8geg&ab_channel=CraylorMade">Different between hosting</a><br><a href="https://www.top10.com/hosting/comparison?utm_source=google&kw=hosting&c=543733688286&t=search&p=&m=e&adpos=&dev=c&devmod=&mobval=0&network=g&campaignid=87845628&groupid=130392847161&targetid=kwd-10071570&interest=&physical=9040379&feedid=&a=2707&ts=hi&topic=&test=&clicktype=&gclid=CjwKCAjwpqCZBhAbEiwAa7pXebgXp-HemoHQ4DCEsFYZDSxx-9AdOYSja23VAuluwYXuaYmxh2dI8xoCKV0QAvD_BwE">Top 10 Hosting Service</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Hosting</tag>
      </tags>
  </entry>
  <entry>
    <title>電腦與外界的通訊方式-輸入/輸出(I/O)管理</title>
    <url>/code-blog/2022/09/27/OS_IO/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>許多Process的執行除了依賴CPU的運算及Memory的儲存，也依賴於其他設備，其中一部分專門用於接受使用者輸入及引導輸出的設備，被稱為I&#x2F;O設備，I&#x2F;O就是input及output的簡稱。</p>
<p>透過今天的內容，會稍微了解IO管理的設計，以及是透過什麼方式整合IO設備與CPU的溝通。</p>
<span id="more"></span>

<h2 id="IO管理的目標"><a href="#IO管理的目標" class="headerlink" title="IO管理的目標"></a>IO管理的目標</h2><ul>
<li>易用: 方便用戶使用</li>
<li>效率: 提高系統的併發工作能力</li>
<li>防錯: 增加設備的可靠及安全性</li>
</ul>
<h2 id="IO流程"><a href="#IO流程" class="headerlink" title="IO流程"></a>IO流程</h2><p>當系統發出指令需要執行IO功能時的流程是什麼呢?<br>我後來發現先大概看一下流程有個全觀的認識，後面了解起來會比較清楚。</p>
<p>以下資料來自<a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">Day-17 I&#x2F;O運作</a></p>
<table>
<thead>
<tr>
<th align="left">流程</th>
<th align="left">動作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User process發出I&#x2F;O request給OS</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">OS收到請求，可能暫停此process執行，並執行相對應的system calls。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">kernel的I&#x2F;O-subsystem會pass此請求給<strong>Device driver</strong>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Device driver依此請求設定對應的I&#x2F;O commands參數給<strong>Device Controller</strong>。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Device Controller啟動，監督I&#x2F;O-Device之I&#x2F;O運作進行。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">在此時，OS可能將CPU切給另外一個process執行。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">後續步驟根據<strong>IO控制方式</strong>。</td>
</tr>
</tbody></table>
<p>後面在介紹各個粗體的字詞後，我覺得對IO就會有個基本的認識了</p>
<h2 id="控制器Registers"><a href="#控制器Registers" class="headerlink" title="控制器Registers"></a>控制器Registers</h2><p>為了達到模組化及通用，一般會將IO區分為機械、電子兩個部分，機械通常是IO設備功能本體，而電子的部分會是用來連接系統的一塊主機板，稱作。</p>
<p><img src="https://i.imgur.com/UJtbyjM.png"><br>控制器包含三個重要的部分:</p>
<ul>
<li>Command Register: 存放CPU所呼叫的命令，讓CPU控制裝置。</li>
<li>Status Register: 存放CPU傳來的狀態資訊，讓CPU了解裝置狀態。</li>
<li>Data Register: 存放預備輸入或輸出的資料</li>
</ul>
<p>透過這三個控制器，操作系統簡化了開發不同設備的介面，有點像是操作系統預先設定好幾個標準介面要求IO設備去符合他們，好處是操作系統開發起來省力，並且可以提高設備的擴充性。</p>
<p>換個角度想就是，如果各家IO設備都有自己的API要求系統去處理，一是會累死系統開發人員，二是這樣就要等到系統支援才有辦法讓IO設備被系統使用。</p>
<h2 id="IO控制"><a href="#IO控制" class="headerlink" title="IO控制"></a>IO控制</h2><p>我自己是根據CPU介入的程度來分為以下4種:</p>
<ol>
<li>Process直接控制</li>
<li>Polling I&#x2F;O</li>
<li>Interrputed I&#x2F;O</li>
<li>DMA I&#x2F;O</li>
</ol>
<h3 id="Process直接控制"><a href="#Process直接控制" class="headerlink" title="Process直接控制"></a>Process直接控制</h3><p>直接由Process控制IO，優點是簡單易實現，缺點就是在IO傳輸時，CPU也被迫閒置等待。</p>
<h3 id="Polling-I-x2F-O"><a href="#Polling-I-x2F-O" class="headerlink" title="Polling I&#x2F;O"></a>Polling I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，在執行其他Process時會在完成指令週期時去輪詢polling裝置控制器確認是否完成。</p>
<p>因為CPU會有polling的成本，等於擠壓到執行Process的時間，適合Device執行速度的狀況，不然每次執行週期可能會需要輪詢過多device。</p>
<h3 id="Interrputed-I-x2F-O"><a href="#Interrputed-I-x2F-O" class="headerlink" title="Interrputed I&#x2F;O"></a>Interrputed I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，IO會在執行完畢後發出中斷指令，系統一樣在完成指令週期時做檢查，不管變成僅檢查中斷指令。</p>
<p>和Polling的差異在IO是否會發出中斷指令，CPU是否能夠處理，若支援這樣的機制，好處是CPU可以減少輪詢時間。</p>
<h3 id="DMA-I-x2F-O"><a href="#DMA-I-x2F-O" class="headerlink" title="DMA I&#x2F;O"></a>DMA I&#x2F;O</h3><p>透過建立一個直接的數據通路，以及授權讓一個DMA控制器對數據通路有存取的權力，使得CPU自由~~~</p>
<p>控制方式是，CPU在需要IO功能時授權DMA控制器，DMA會自行與IO溝通，並將所有工作完成，並且因為有一個直接的數據通道，DMA連數據傳輸也會處理，否則像Interrputed I&#x2F;O仍需要由CPU處理數據，並發出中斷命令給CPU，CPU需要參與的部分僅在IO功能的開始及結束。</p>
<p>優點是因為解放CPU，CPU的使用率大幅提升，但因為數據通道直接放在Memory，DMA會跟CPU搶Memory的使用權。</p>
<h2 id="硬體驅動程式"><a href="#硬體驅動程式" class="headerlink" title="硬體驅動程式"></a>硬體驅動程式</h2><p>除了controller，IO中另外一環重要的部分為device driver。</p>
<p>驅動程式負責理解系統對IO設備發出的指令，並轉化成IO硬體能理解的內容以執行工作。</p>
<p>根據以下這張圖，應該可以更清楚device driver跟device controller之間的關係。</p>
<p><img src="https://i.imgur.com/9kvjQpK.png"></p>
<p>剛好回頭對照前面IO功能在執行時的流程圖<br>system call被呼叫時，指令會透過kernel傳給device driver，在透過device driver將指令轉化成IO controller能理解的形式並傳送過去。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天就這樣啦~<br>明天會來看看關於Unix的標準-POSIX。</p>
<p>此文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/27/OS_IO/">部落格</a>，歡迎來逛逛喔~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/23.html">IO核心子系統</a><br><a href="https://www.omscs-notes.com/operating-systems/io-management/">IO Management</a><br><a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">IO運作</a><br><a href="https://www.quora.com/What-is-the-difference-between-device-driver-and-device-controllers">What-is-the-difference-between-device-driver-and-device-controllers</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>行程間通訊(Inter Process Communication)</title>
    <url>/code-blog/2022/09/25/OS_Inter_Process_Communication/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在系統內，Process或是Thread若需要與其他合作，就須要有溝通的方式，而溝通的原因包括資料分享需要、模組…等等，這些就被稱為行程間通訊。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>多個 process&#x2F;thread 內部要去溝通，都統稱叫做 IPC。</p>
<p>關於這點我曾經有點困惑，為什麼Thread之間的溝通也被稱為行程間通訊，我個人給他的解釋是，因為Thread本身也可以算是一個Process，只是跟其他同Process的Thread共享了部分記憶體空間。</p>
<p><del>不過說不定只是那時候的人取錯名字了?</del></p>
<h2 id="情境需要"><a href="#情境需要" class="headerlink" title="情境需要"></a>情境需要</h2><ul>
<li>資訊分享: node.js經過cluster產生的child process和main process需要溝通。</li>
<li>加速運算: Parallel</li>
<li>模組化</li>
<li>方便</li>
</ul>
<h2 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h2><ul>
<li>Shared Memory</li>
<li>Message Passing</li>
</ul>
<h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>共享記憶體以進行通訊，使用時不需要kernel。<br>不過若是兩個Process之間想要使用這個方式進行通訊會因為需要額外建立共享的memeory區塊而發出system call了。</p>
<h2 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h2><p>要實現這個通訊方式，必須包含</p>
<ul>
<li>溝通方法: send &amp; receive</li>
<li>溝通管道</li>
</ul>
<p>在有些資料中，雖然會將IPC分為更多類，不過我最後根據<a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ipc</a>這份資料，認為理解他們的方式應視為在討論Message Passing實踐時的相異之處。</p>
<p>其中包括討論:</p>
<ul>
<li>溝通管道如何被建立?<br>通常會討論是直接通訊Direct Communication或是間接通訊Indirect Communication。</li>
<li>一個管道是否可以與兩個以上的Process有關?</li>
<li>Process與Process之間可以有多少管道?</li>
<li>管道的容量有多少?可容納的訊息是固定還是可變的</li>
<li>管道是雙向還是單向的</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>看了資料後才發現其實IPC蠻靠近我們的<br>包括我們在shell裡面常用的pipe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find a | xargs grep &#x27;something&#x27;</span><br></pre></td></tr></table></figure>
<p>因為每個指令是一個process，前指令在將結果傳給後指令接收時使用的就是IPC。</p>
<p>另外瀏覽器請求server的通信也是。<br>不過IPC的細節實在太燒腦了，差點寫不完只好先停在這裡，若之後真的有機會再回頭來更新吧。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><!-- Tanenbaum & Bos 的Modern Operating Systems -->
<p><a href="https://hackmd.io/@YiZjennnnn/OS_Note/https%3A%2F%2Fhackmd.io%2F%40YiZjennnnn%2Fipc_interprocess_communication?type=book">IPC (Interprocess Communication)</a><br><a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ip</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix的標準-POSIX Basics</title>
    <url>/code-blog/2022/09/28/OS_POSIX_Basics/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>POSIX到底是什麼神秘的東西呢?老實說，在roadMap提到這個單字前，我是真的完全不知道他是什麼XD</p>
<p>其實他就是一種interface的標準，為了要讓作業系統之間的相容性提高，所以符合POSIX的應用程式都會有一個重要的特性是:</p>
<blockquote>
<p>應該要能與其他符合POSIX標準的作業系統相容</p>
</blockquote>
<p>於是今天會講到一些歷史，並提到關於POSIX具有移植性的一些原因。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>有人說他的全稱是Portable Operating System Interface，並且最後加上X代表Unix，不過官方似乎也沒針對名字的全稱給出解釋。<br>他是由IEEE制定的，並且符合此標準的應用程式應該具有如前言所說的特性。</p>
<p>也因為這樣，在Linux及類Unix系統上多數工具的行為會幾乎相同。<br>這邊為什麼會將Linux與Unix分開說呢?<br>因為Linux雖然是根據大部分的POSIX的標準實現的，但他是從頭開發的，所以根本上他並不與Unix有實質的關聯。</p>
<h2 id="歷史小故事"><a href="#歷史小故事" class="headerlink" title="歷史小故事"></a>歷史小故事</h2><p>Unix在1974年由貝爾實驗室對外發布，自此開始出現了多個版本，並也有Unix廠商試圖加上一些不相容的特性來讓系統與其他有所區隔。<br>而後，為了提高相容性及應用程式的可移植性，IEEE開始著手將Unix的開發標準化，後由Richard Stallman命名為”POSIX”。</p>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>這邊會談到為什麼遵循POSIX就代表具有可移植性。<br>基本上作業系統有兩種方式可以跟硬體溝通:</p>
<ol>
<li>system call</li>
<li>library function</li>
</ol>
<h3 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h3><p>由作業系統提供給Process的溝通介面，因為是由作業系統直接提供的，所以不同的作業系統他們所提供的system call介面可能不同。</p>
<h3 id="library-function"><a href="#library-function" class="headerlink" title="library function"></a>library function</h3><p>作業系統會提供另一種方式，將很多過程封裝成一些常用的函式，比如說，一個寫入的函式可能包含很多記憶體、硬碟的操作。<br>而所謂的符合POSIX其實就是指:</p>
<blockquote>
<p>這些函式需要輸入的參數、型別、回傳值等都符合POSIX要求的規範</p>
</blockquote>
<p>根據下圖你就能看到事實上其實一個function可能封裝了system call在其中，那這樣可以帶來什麼好處呢?<br><img src="https://i.imgur.com/FGJlGxm.png"></p>
<h3 id="使用library-function的好處"><a href="#使用library-function的好處" class="headerlink" title="使用library function的好處"></a>使用library function的好處</h3><ol>
<li>節省成本: 會這樣說的原因，需要回到前幾天談過的Kernel mode，當我們使用system call的時候其實會經過mode的轉換，這其實需要一些成本，我們可能會接著問，那library也會使用system call不會嗎?當然會，所以我們的角度會變成，盡可能在進入kernel mode時完成大部分的system call。</li>
<li>可移植: 回到原本談得移植性，當我們的Program是用符合POSIX標準的library與硬體溝通時，這代表這段程式碼可以被直接搬到一樣符合標準的系統，就算這些不同的library內部實現這些介面的方式不同，但這並不是開發人員在乎的事情。不過如果是直接使用system call呢?假如兩邊使用的參數或甚至名稱不同，那段就要經過檢查後重寫…</li>
</ol>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次的學習解答了為什麼我們在Linux或是其他類Unix的系統上所使用的script大部分都無法搬到windows上使用XD<br>而且通過資料，也看到windows從windows NT原本也期望符合POSIX，但最終放棄，他目前是改為面對開發人員，推出了wsl(Windows Subsystem for Linux)。</p>
<p>到今天為止總算在OS overview的部分告一段落了，後面幾天開始就是DB的一些overview囉!<br>明天見~~</p>
<p>本文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/28/OS_POSIX_Basics/">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>閒聊一下，我在寫這天的內容時，使用的正是wsl2，一般而言他還是蠻好用的，他讓我們可以在windows有好用的GUI基礎上，可以透過vscode或是terminal實現類似在linux上開發的感受，我個人覺得是可行的。<br>不過今天也出現問題，在複製照片想貼進md文件時出現了錯誤，看來是在同步剪貼簿時對於照片的轉換出現了問題…</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.baeldung.com/linux/posix">A Guide to POSIX</a><br><a href="https://unix.stackexchange.com/questions/11983/what-exactly-is-posix/220877#220877">What exactly is POSIX?</a><br><a href="https://zhuanlan.zhihu.com/p/392588996">posix是什麼都不知道，還好意思說你懂Linux</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>POSIX</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(上)-行程管理</title>
    <url>/code-blog/2022/09/23/OS_Process/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>行程是CPU分配資源的最小單位，以後還會聊到，甚至就連docker的container在run的時候就是一個process，很有趣吧，就來稍微認識一下~</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>一個較好記憶的說法會將行程解釋成運行中的應用程式(Application)，但有個比較貼切的說法是: 行程是一個正在運行中的應用程式實例。</p>
<p>實例隱含的意思是，由一個應用程式而建立的行程可以有多個，且雖然他們皆由同一個應用程式而來，他們可以具備不同狀態。</p>
<h2 id="行程架構"><a href="#行程架構" class="headerlink" title="行程架構"></a>行程架構</h2><p><img src="https://i.imgur.com/DlIreU0.png"></p>
<blockquote>
<p>引用自 <a href="https://www.guru99.com/process-management-pcb.html">https://www.guru99.com/process-management-pcb.html</a></p>
</blockquote>
<p>此圖大致代表Process在記憶體裡的結構，</p>
<ul>
<li>Stack: 暫時性資料，例如Function Parameters、Local variables</li>
<li>Heap: 執行程式碼所需要的動態工作區</li>
<li>Data: 儲存全域變數等</li>
<li>Text: 程式碼所在</li>
</ul>
<h2 id="行程生命週期"><a href="#行程生命週期" class="headerlink" title="行程生命週期"></a>行程生命週期</h2><p><img src="https://i.imgur.com/KgOOxn6.png"></p>
<blockquote>
<p>引用自 <a href="https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60">https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60</a></p>
</blockquote>
<p>共有五種狀態</p>
<table>
<thead>
<tr>
<th>狀態</th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td>new創建</td>
<td align="left">初始狀態，分配及建立PCB以及其他資源，在完成上述工作後進入ready</td>
</tr>
<tr>
<td>ready就緒</td>
<td align="left">在隊列按照CPU Scheduling的演算法等待搶奪CPU以完成工作</td>
</tr>
<tr>
<td>running工作</td>
<td align="left">一旦搶奪到CPU，此狀態會被設置為工作中，並執行應用程式中的指令。在與ready狀態切換時，會作Context Switch</td>
</tr>
<tr>
<td>waiting等待</td>
<td align="left">如果因為事件或是IO速度的差異導致等待，就會停在此</td>
</tr>
<tr>
<td>terminated終止</td>
<td align="left">完成執行、被迫結束(比如在硬性即時系統)或者遇到錯誤時就會進入此狀態</td>
</tr>
</tbody></table>
<h2 id="Process-Control-Block-PCB"><a href="#Process-Control-Block-PCB" class="headerlink" title="Process Control Block, PCB"></a>Process Control Block, PCB</h2><p>記錄行程相關狀態資訊的資料區，每個行程都有自己的一個，並在Process創建時被建立。<br>其內容包含:</p>
<table>
<thead>
<tr>
<th align="left">項目</th>
<th align="left">內容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行程狀態process state</td>
<td align="left">流程生命週期的狀態</td>
</tr>
<tr>
<td align="left">程式計數器process counter</td>
<td align="left">紀錄下一個要執行的指令的位址</td>
</tr>
<tr>
<td align="left">CPU暫存器保存區</td>
<td align="left">不在running state時，CPU暫存器內容會被保存在此</td>
</tr>
<tr>
<td align="left">排班資訊</td>
<td align="left">例如行程優先等級(priority)等排班時所需要的參數</td>
</tr>
<tr>
<td align="left">記憶體資訊</td>
<td align="left">其內容根據記憶體系統的種類而定</td>
</tr>
<tr>
<td align="left">帳號資訊Accounting Information</td>
<td align="left">process所屬的使用者帳號(user id)、行程代號(process identification)、時間限制、已經使用掉的處理機時間、進入系統之實際時間</td>
</tr>
<tr>
<td align="left">IO狀態資訊</td>
<td align="left">如所配置之輸出入裝置串列、開啟(Opened)之檔案串列等資訊</td>
</tr>
</tbody></table>
<p>大部分資訊由參考資料2來的，並統整了其他資料的內容，所以更詳細可以看參考資料2。</p>
<h2 id="Process-Create"><a href="#Process-Create" class="headerlink" title="Process Create"></a>Process Create</h2><p>在OS內，Process可以建立child process，因此所有的排程可以組成一個樹狀結構。</p>
<p>如果你手邊有linux系統的話，可以使用 <code>pstree -aup</code> 看到在你的電腦裡的process的樹狀圖。</p>
<p><img src="https://i.imgur.com/Mjv8Wl7.png"></p>
<p>如上圖，甚至可以知道我是在zsh之下執行的這個指令XD</p>
<p>大部分的OS會支援兩種Process Create的方式</p>
<ul>
<li>Fork: 複製父行程的PCB到子PCB</li>
<li>Exec: 替換子行程的資料，初始化新的PCB資料</li>
</ul>
<p>所以建立新的Process就是兩者混用，先Fork一個子行程後，再Exec初始化子行程。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://medium.com/@akhandmishra/operating-system-process-and-process-management-108d83e8ce60">Operating System: Process and Process Management</a><br><a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html">PCB</a><br><a href="https://ithelp.ithome.com.tw/articles/10202866">程序(process)概念–上</a><br><a href="https://www.tutorialspoint.com/inter_process_communication/inter_process_communication_process_creation_termination.htm">Process Creation</a><br><a href="https://ithelp.ithome.com.tw/articles/10276152?sc=rss.iron">Process</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
      </tags>
  </entry>
  <entry>
    <title>作業系統(Operating System/OS) Overview(上)</title>
    <url>/code-blog/2022/09/21/OS_System-Concept_Overview/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從今天開始進入OS一般知識的範圍，透過了解我們正運行中的程式(Process)在OS如何運作的過程及相關知識，包含I&#x2F;O, Thread, Memory…等，可以進一步優化程式。</p>
<p>稍微具體舉個例子來說，以node.js來說，作為單執行緒(thread)的執行環境，若一下出現大量的使用者情求時會是什麼狀況呢，如果已經在工作的人，你可以想像辦公室明明有很多人，但電話只跑到你這裡，你頂多叫他們做點事情幫忙，但最終還是你一個人處理所有的電話…情何以堪XD</p>
<p>為了解決這個問題，因此有了pm2套件、原生的cluster及worker threads，他們各自有不同的問題解決邏輯，或許通過這段時間的鑽研我們可以稍微探討這些差異。</p>
<p>我個人是蠻期待這部分的學習，那，就開始今天的OS overview吧。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><blockquote>
<p>一組主管並控制電腦操作、運用和執行硬體、軟體資源和提供公共服務來組織使用者互動的相互關聯的系統軟體程式。 – <a href="https://zh.wikipedia.org/zh-tw/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">維基百科</a></p>
</blockquote>
<p>這邊我用我的方式來理解作業系統是: 提供易於操作的介面，讓程式開發者&#x2F;使用者可以用更簡單直覺的方式操作硬體。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>於是，作業系統的用途包含但可能不限於以下:</p>
<ol>
<li>控制及管理硬體資源</li>
<li>提供使用者介面</li>
<li>程式的錯誤預防</li>
</ol>
<p>根據需求情境及使用者對象，其考量而產生的作業系統型態可能會完全不一樣，比如說，家用個人電腦的目標是讓使用者更方便的使用系統，所以可能會更在意GUI(圖形化介面)的方便性；而伺服器的目標是資源的隔離性及使用率最佳化，可能面向的對象多是開發者，其介面可能僅會使用CLI(文字命令介面)。</p>
<h2 id="作業系統與硬體的互動"><a href="#作業系統與硬體的互動" class="headerlink" title="作業系統與硬體的互動"></a>作業系統與硬體的互動</h2><p>一般來說會分成使用者(User)及應用程式(Program)透過OS與硬體互動，使用者通過OS的命令直譯器(Command Interpreter)與硬體互動，而當使用者在操作應用程式時，應用程式會對OS做系統呼叫(System Call)，進而與硬體層溝通，完成使用者指定的操作。</p>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><p>在進入後面一般系統種類介紹前，也想先對幾個名詞作概要的解釋，會對於後面的內容有比較好的理解。</p>
<h3 id="CPU-Scheduling-Short-term-Scheduling"><a href="#CPU-Scheduling-Short-term-Scheduling" class="headerlink" title="CPU Scheduling(Short-term Scheduling)"></a>CPU Scheduling(Short-term Scheduling)</h3><p>最早期的系統其實是單純的順序，意思是指，CPU會按照程式的執行順序，依序把工作完成，其中常有造成CPU珍貴的運算資源被閒置的狀況，像是程式設計錯誤，或是因為硬體的速度不一，導致CPU等待其他工作完成…等等。</p>
<p>因此為了得到最大的CPU使用率，會藉由適當的排班演算法，先CPU處理該process(CPU Burst)，接著做I&#x2F;O資料的傳送(I&#x2F;O Burst)，process會在這兩個狀態一直循環，最後在工作完成後呼叫一個終止Process的System Call作為結束。</p>
<p>這可以說是後面的系統類別在設計時的核心之一，目標式在確保CPU使用率的狀況下，作出最符合當前系統情境的需求的決策。</p>
<h3 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h3><p>CPU使用權轉移時，需要儲存舊的Process資訊，載入新Process資訊，這個工作就稱之為Context Switching。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>內容遠比我想得來的多了，不得已之好分成兩天完成來完成了XD<br>明天會開始介紹作業系統的種類。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10232695">Node Cluster 讓你的 Thread 不再孤軍奮戰</a><br><a href="https://stackoverflow.com/questions/56656498/how-do-cluster-and-worker-threads-work-in-node-js">Different between cluster and worker thread</a><br><a href="https://www.youtube.com/watch?v=Cl0uql06KK0&ab_channel=%E3%80%90%E6%9D%B0%E5%93%A5%E6%95%B8%E4%BD%8D%E6%95%99%E5%AE%A4%E3%80%91">作業系統簡介</a><br><a href="https://ithelp.ithome.com.tw/articles/10203990">CPU Scheduling</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>OS</tag>
        <tag>CPU Scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>作業系統(Operating System/OS) Overview(下)</title>
    <url>/code-blog/2022/09/22/OS_System_Classification_Overview/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介紹各個系統作業類別，透過了解系解的分類及概要的內容，會對於作業系統有更進一步的認識的~<br>那就開始吧!</p>
<span id="more"></span>

<h2 id="作業系統類別"><a href="#作業系統類別" class="headerlink" title="作業系統類別"></a>作業系統類別</h2><ol>
<li>多元程式規劃 Multiprogramming System</li>
<li>分時系統 Time Sharing System</li>
<li>分散式系統 Distributed System</li>
<li>即時系統 Real Time System</li>
<li>集成&#x2F;叢集式系統 Clustered System</li>
</ol>
<h3 id="多元程式規劃Multiprogramming-System"><a href="#多元程式規劃Multiprogramming-System" class="headerlink" title="多元程式規劃Multiprogramming System"></a>多元程式規劃Multiprogramming System</h3><ul>
<li>定義: 存在多組Process同一段時間內同時執行</li>
<li>目的: 避免CPU閒置，提升使用率</li>
</ul>
<p>系統內存在許多等待執行的Process，而透過CPU Scheduling讓CPU可以在不同Process中切換(Context Switch)，讓CPU保持忙碌減少閒置。</p>
<p>為什麼需要切換，因為為了完成軟體需執行的動作，可能需要依賴除了CPU以外的硬體，若CPU的運算過程出現需等待其他硬體先完成後才能繼續執行的事件，就會造成閒置(idle)。</p>
<p>一般而言，Multiprogramming degree(註1)越高，CPU使用率越高，意思是指說越不會出現因為等待其他軟體操做其他硬體工作而造成閒置，除非遇到輾轉現象(Thrashing(註2))。</p>
<h3 id="分時系統-Time-Sharing-System"><a href="#分時系統-Time-Sharing-System" class="headerlink" title="分時系統 Time Sharing System"></a>分時系統 Time Sharing System</h3><ul>
<li>定義: 屬於Multiprogramming System其中之一，透過資源共享技術，使User認為有各自專屬的系統存在。</li>
<li>技術:<ul>
<li>CPU: CPU Scheduling，採用Round-Robin(註3)</li>
<li>Memory: 共享Memory Space</li>
<li>I&#x2F;O device: Spooling(註4)</li>
</ul>
</li>
</ul>
<p>此系統容許多人同時使用，並對個別的請求盡可能快的產生反應，如果這個輪流使用資源的速度夠快，會看起來像是每個人都在同時與該系統互動，故也會被稱為交談式系統，像是遊戲。</p>
<h3 id="分散式系統-Distributed-System"><a href="#分散式系統-Distributed-System" class="headerlink" title="分散式系統 Distributed System"></a>分散式系統 Distributed System</h3><p>可分成兩類: </p>
<ol>
<li>緊密耦合Tightly Coupled: Multiprocessor, Parallel</li>
<li>鬆散耦合Loosely Coupled: Distributed</li>
</ol>
<h4 id="緊密耦合-Multiprocessor-x2F-Parallel"><a href="#緊密耦合-Multiprocessor-x2F-Parallel" class="headerlink" title="緊密耦合 Multiprocessor&#x2F;Parallel"></a>緊密耦合 Multiprocessor&#x2F;Parallel</h4><ul>
<li>定義: 同一機器具有2顆以上的CPU或Processor存在，且同時符合以下特性<ul>
<li>共享記憶體、I&#x2F;O設備、Bus(註5)</li>
<li>受同一個Clock及OS的控制</li>
<li>CPUs之間的資料交換，採Share Memory(註6)</li>
</ul>
</li>
</ul>
<p>支援Parallel Computing，可將Processes或單一Process上subtasks指派到不同CPU，平行直行。</p>
<ul>
<li><p>優點:</p>
<ul>
<li>產能: 可同時執行多工作，或單一工作拆分部分。</li>
<li>符合效益: 共用記憶體、I&#x2F;O、BUS，在完成MultiProcessor的演算法之後，就不用用多台電腦叢集，但閒置了必配置的上述資源。</li>
<li>可靠度: 單一Processor掛掉之後可以保證工作繼續維持。</li>
</ul>
</li>
<li><p>問題:<br>n個CPU不等同於n倍效能，會因為前者提到在多工的通訊或共用的資源的競爭導致效能的消耗。</p>
</li>
</ul>
<p>可以想像看看，公司的團隊人數增加兩倍時，就會有兩倍的產能出現嗎…</p>
<ul>
<li>類型細分:<ul>
<li>對稱式多元處理Symmetric Multiprocessing, SMP:<br>每一個Processor功能相同，可靠度較高，單一Processor壞掉會將未完成工作轉移到其他Processor身上，強調負載平衡，想像起來有點像並聯的感覺。</li>
<li>非對稱式多元處理Asymmetric Multiprocessing, ASMP:<br>又稱做Master&#x2F;Slave架構，通常有一個單位(個&#x2F;群)的Master Processor，負責控制、分配Process到其他Processor去運作，效能相對SMP好，但可靠度較差。</li>
</ul>
</li>
</ul>
<h4 id="鬆散耦合-Distributed"><a href="#鬆散耦合-Distributed" class="headerlink" title="鬆散耦合 Distributed"></a>鬆散耦合 Distributed</h4><ul>
<li>定義: 相對於緊密耦合，可以視為多台電腦的叢集。</li>
</ul>
<p>現代網路的運作模式可以視為是這樣的鬆散耦合，通過一些經過標準化的協定傳遞訊息做溝通。</p>
<ul>
<li>類型細分:<ul>
<li>網路作業系統(NOS):<br>在知道其他端點的資訊下，透過網路協定進行訊息溝通。</li>
<li>分散式作業系統(DOS):<br>讓使用者已像是在存取自己資源的方式使用遠方端點資源，資料以及運算全在OS控制之下，使用者無法得知是在遠端或是本端得到資源。</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/zProh6x.png"></p>
<blockquote>
<p>圖片來自碁峯-作業系統理論與實務–第二版(雙色印刷)15-3</p>
</blockquote>
<h3 id="即時系統-Real-Time-System"><a href="#即時系統-Real-Time-System" class="headerlink" title="即時系統 Real Time System"></a>即時系統 Real Time System</h3><ul>
<li>定義: 嚴謹的定義的時間限制，Processor在處理工作時必須在時間內完成，若否即失效。</li>
</ul>
<p>可分成兩類</p>
<ol>
<li>硬性即時系統</li>
<li>軟性即時系統</li>
</ol>
<h4 id="硬性即時系統"><a href="#硬性即時系統" class="headerlink" title="硬性即時系統"></a>硬性即時系統</h4><p>狹義化的即時系統定義，並相對於柔性即時系統。</p>
<ul>
<li>注意限制: 除了OS運作的時間以外，也要考慮系統內的delay(如傳輸、硬體運算等)必須須小於情境所需要的Time Constraint。</li>
<li>OS特性: OS的功能少甚至沒有，以減少干預，強調即時，限制延遲。</li>
<li>使用需求可以想像這個系統是需要在特定時間限制需求的環境下使用的。</li>
</ul>
<h4 id="軟性即時系統"><a href="#軟性即時系統" class="headerlink" title="軟性即時系統"></a>軟性即時系統</h4><p>確保高優先權Process會先於低優先權被完成，且高優先權Process的優先權要維持到工作完成，對比硬性即時系統來看，此系統僅能保證高優先權最先，但不會限定什麼時間完成。</p>
<ul>
<li>注意限制: OS造成的延遲要盡可能縮短，避免優先權反轉(註7)問題。</li>
<li>OS特性: 支援Priority優先權演算法，且優先權不能被Aging(註8)。</li>
</ul>
<h3 id="集成-x2F-叢集式系統-Clustered-System"><a href="#集成-x2F-叢集式系統-Clustered-System" class="headerlink" title="集成&#x2F;叢集式系統 Clustered System"></a>集成&#x2F;叢集式系統 Clustered System</h3><ul>
<li>定義: 其定義有點類似分散式系統: 集合多個CPU完成工作並共享儲存裝置稱為一個clustered，且又透過連線緊密連結。</li>
</ul>
<p>差異的話，相對於Tightly coupled，他不是多個CPU共用相同資源；而相對於loosely coupled，他也不是多個<strong>單獨系統</strong>作訊息溝通。</p>
<p>硬要想像跟理解的話，有點像是多個Tightly coupled系統作loosely coupled，不過每個Tightly coupled系統僅共享儲存裝置這樣。</p>
<p>不過回頭來看，我們要說Tightly coupled系統也是一種Clustered System，應該也是符合定義的吧。</p>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><h3 id="註1-Multiprogramming-degree"><a href="#註1-Multiprogramming-degree" class="headerlink" title="註1- Multiprogramming degree"></a>註1- Multiprogramming degree</h3><p>系統內等待執行的Process數量</p>
<h3 id="註2-Thrashing"><a href="#註2-Thrashing" class="headerlink" title="註2- Thrashing"></a>註2- Thrashing</h3><p>因為Context switch需要記憶體或虛擬記憶體作為資訊存放的地方，於是，當Multingprogramming degreee超過一定程度時，會讓所有Process忙於資訊在記憶體及虛擬記憶體(disk)轉換之中，CPU為了等待完成反而造成閒置。</p>
<h3 id="註3-Round-Robin"><a href="#註3-Round-Robin" class="headerlink" title="註3- Round-Robin"></a>註3- Round-Robin</h3><p>每個Process有固定的配額時間，配額的時間沒完成目前的工作，Process會被迫放棄並讓出CPU的使用。</p>
<h3 id="註4-Spooling"><a href="#註4-Spooling" class="headerlink" title="註4- Spooling"></a>註4- Spooling</h3><p>為了因應速度不相同的裝置，在兩者之間設置緩衝區(Buffering)，以減少兩者速度傳輸造成的閒置或是順序錯誤。</p>
<p>常見的舉例像是: 印表機處理多個裝置的影印工作不會錯置順序。</p>
<h3 id="註5-匯流排Bus"><a href="#註5-匯流排Bus" class="headerlink" title="註5- 匯流排Bus"></a>註5- 匯流排Bus</h3><p>指的是電腦組件之間交換資料的方式，我的理解就是主機板上連接著組件間的線路。</p>
<h3 id="註6-Share-Memory"><a href="#註6-Share-Memory" class="headerlink" title="註6- Share Memory"></a>註6- Share Memory</h3><p>允許兩個不相關的Process進入讀取、寫入的邏輯記憶體。</p>
<h3 id="註7-Priority-Inversion優先權反轉"><a href="#註7-Priority-Inversion優先權反轉" class="headerlink" title="註7- Priority Inversion優先權反轉"></a>註7- Priority Inversion優先權反轉</h3><p>高優先權Process在特定情況下，遭到低優先權阻擋而無法完成工作。</p>
<p>特定情況像是，雖然高優先權拿到了CPU的使用權，但低優先權霸佔了高優先權完成工作時需要的資源，造成CPU idle。</p>
<h3 id="註8-aging"><a href="#註8-aging" class="headerlink" title="註8-aging"></a>註8-aging</h3><p>系統根據特定規則，將系統內很長時間未完成工作的process逐步提高其 Priority的技術。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在了解了這些不同的作業系統類別之後，我發現這些作業系統的設計其實都是跟著實務上使用的需求而專門誕生的，只是後續才被整理出這些類別才是。</p>
<p>在大概了解完OS之後，其實還是有很多大大小小的內容可以在深入了解一些，那接著就是在介紹時常常提到的行程Process囉!</p>
<p>此篇文章同步發表於<a href="https://medium.com/on-my-way-coding/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1-operating-system-os-overview-%E4%B8%8B-37670e4c368a">部落格</a>，歡迎逛逛~</p>
<p>如果沒有前面那是正常的，因為我從今天才決定要放部落格的XD</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.youtube.com/watch?v=tA4KiYrFdAM&ab_channel=%E3%80%90%E6%9D%B0%E5%93%A5%E6%95%B8%E4%BD%8D%E6%95%99%E5%AE%A4%E3%80%91">作業系統簡介</a><br><a href="https://ithelp.ithome.com.tw/articles/10203950">即時作業系統</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">Shared Memory</a><br><a href="https://zh.m.wikipedia.org/zh-tw/%E6%80%BB%E7%BA%BF">匯流排</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(中)-執行緒管理</title>
    <url>/code-blog/2022/09/23/OS_Thread/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天會討論執行緒Thread，是一個我覺得很容易跟行程Process混淆的概念，為了學習跟整理這個概念，我們可以踩在前人的肩膀上前進XD</p>
<p>透過一張別人整理出來的Process、Thread比較圖，我們來問問一些「為什麼?」。<br>而透過回答經過整理的問題，可以看到兩者的差別及是什麼造成這些差別。</p>
<p>而最後我相信通過探究這些差異的過程，不只可以幫助理解Thread，也同時可以回頭幫助了解Process~</p>
<span id="more"></span>

<h2 id="執行緒Thread"><a href="#執行緒Thread" class="headerlink" title="執行緒Thread"></a>執行緒Thread</h2><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="left">Process</th>
<th align="left">Thread</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定義</td>
<td align="left">在執行中的程式</td>
<td align="left">行程的一部分</td>
</tr>
<tr>
<td align="left">輕量</td>
<td align="left">不輕量</td>
<td align="left">輕量</td>
</tr>
<tr>
<td align="left">終止時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">建立時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">溝通</td>
<td align="left">行程間的溝通較費力且相對Thread來說更久</td>
<td align="left">溝通容易且相對較短</td>
</tr>
<tr>
<td align="left">上下文交換</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">資源 (CPU時間)</td>
<td align="left">消耗較多資源</td>
<td align="left">較少</td>
</tr>
<tr>
<td align="left">記憶體</td>
<td align="left">幾乎隔離</td>
<td align="left">有共享的記憶體位置</td>
</tr>
<tr>
<td align="left">資料共用</td>
<td align="left">不共用資料</td>
<td align="left">共享資料</td>
</tr>
<tr>
<td align="left">from <a href="https://www.guru99.com/difference-between-process-and-thread.html">Process vs Thread – Difference Between Them</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="為什麼說Thread是Process的一部分"><a href="#為什麼說Thread是Process的一部分" class="headerlink" title="為什麼說Thread是Process的一部分?"></a>為什麼說Thread是Process的一部分?</h3><p>我們可以用三種角度來看這個定義，看能不能釐清他們!</p>
<h4 id="角度1-工廠藍圖想像"><a href="#角度1-工廠藍圖想像" class="headerlink" title="角度1: 工廠藍圖想像"></a>角度1: 工廠藍圖想像</h4><p>我們先用比較淺顯的想像開頭:</p>
<blockquote>
<p>想像我們按照「藍圖」建立「工廠」，「工廠」裡面會聘請「工人」來完成工作。</p>
</blockquote>
<p>上面提到的藍圖、工廠、工人分別就是Program、Process、Thread。<br>所以實際上完成功作的是作為工人的Thread。</p>
<p>但這邊我在看的時候產生一個困惑，我們在操作系統簡介不是曾說: </p>
<blockquote>
<p>Process會根據CPU scheduling機制搶占CPU資源</p>
</blockquote>
<p>這樣到底是Process還是Thread完成工作呢?</p>
<p>其實這句話依舊是正確的，只是說的還不夠多，要了解這點，我們需要先知到Thread到底是什麼又存在哪裡。</p>
<p>透過一張圖的幫忙會更容易理解了。</p>
<h4 id="角度2-單執行緒行程-vs-多執行緒行程"><a href="#角度2-單執行緒行程-vs-多執行緒行程" class="headerlink" title="角度2: 單執行緒行程 vs 多執行緒行程"></a>角度2: 單執行緒行程 vs 多執行緒行程</h4><p><img src="https://i.imgur.com/Np4e2XK.png"></p>
<blockquote>
<p>from <a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">程序、行程(process)</a></p>
</blockquote>
<p>這是一張單執行緒Process與多執行緒Process的比較圖。<br>我們回到表格中的定義:</p>
<blockquote>
<p>執行緒是行程的一部分</p>
</blockquote>
<p>這樣是不是就很明顯地看到這個定義了呢?<br>執行緒確實是行程的一部分，於是昨天提到的行程結構，其實就是一個單執行緒行程。</p>
<p>確切來說，執行緒的結構包含獨立的: stack、register、counter<br>並且與其他Thread共用code, date(共用變數區), files。</p>
<p>正因為每個Thread有自己的Register、Counter、Stack，所以他們可以自己決定執行哪段程式，也就是說:</p>
<blockquote>
<p>每段執行緒可以執行各自片段的程式碼以完成Process需要完成的工作</p>
</blockquote>
<h4 id="角度3-概念總結"><a href="#角度3-概念總結" class="headerlink" title="角度3: 概念總結"></a>角度3: 概念總結</h4><p>最後來整理一下，並帶到最後一個對Thread及Process之間差異的描述:</p>
<blockquote>
<p>Process是OS分配資源之對象單位，而Thread才是OS分配CPU時間之對象單位<br>  – <a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a></p>
</blockquote>
<h3 id="為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少"><a href="#為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少" class="headerlink" title="為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?"></a>為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?</h3><!-- 建立Thread就像在固定好，且較小的範圍建立資料 -->
<p>Process建立流程包括:</p>
<ol>
<li>向系統註冊，讓系統紀錄執行清單，並標上PID。</li>
<li>分配適當的資源，包含CPU使用權及獨立的資料儲存空間。</li>
</ol>
<p>這個過程會申請空白PCB並初始化資料並填入PCB。</p>
<p>而因為Thread共用了大部分Process的狀態(這邊幫助你回憶一下，Thread是Process的一部分XD)，所以可以減少建立及管理的開銷。<br>另外一部分牽涉到Context Switch的成本，因為行程在進行Context Switch時，需要保存整個Process的狀態資訊，包括Counter、CPU registers、PCB，在處理這個過程花費的CPU相對Thread較多，因為Thread僅需要保存他自己的CPU register而已。</p>
<p>用工廠的說法來描述這些成本的差異好了。<br>建一個工廠需要選地址、找監督特別記錄所有工廠的資料、建立所有流程；而多請一個員工，因為原本的工廠裡面的流程都還在，所以大部分要做的事情都可以被省略。</p>
<h3 id="為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行"><a href="#為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行" class="headerlink" title="為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?"></a>為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?</h3><p>一個相同行程裡面多個Thread在被建立時，都可以共用同一個Process裡面的區塊的資料，這個區塊就是Heap，可以把這個區塊理解成像是全域變數的存在。</p>
<p>而不同Process在被建立時，他們彼此之間就會被分配不同的記憶體位置，因為沒有共用記憶體，所以Process之間如果需要溝通就要靠其他方法，一般統稱這些方法為Inter-process communication(IPC)，而這個過程相對不易，但也確保了行程內的資料不易被汙染。</p>
<p>盡可能保持Process之間的獨立性是有它的意義的，就好像我們現在可以毫無猶豫的ctrl + alt + delete直接強制關閉行程卻不用擔心造成其他行程的影響，因為他們之間互不依賴。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過了解Thread，我們進一步釐清了Thread這個概念被建立想要去處理的問題是快速的多工，並提高了資源(CPU、Memory…)的使用率。<br>於是接下來會進到下集，我們要談的Concurrency，可以說Thread幾乎是為此而生XD至於為什麼這麼說，下一篇也會試圖解釋這件事情!<br>那就明天見囉~</p>
<p>本文章同步分享於<a href="">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>其實原本是要將內容分成上下兩個部分，但Process、Thread、Concurrency這三個主題實在太息息相關，可以講的東西又太多了。<br>不知不覺，篇幅就大到一天要讀完太過難受，為了閱讀體驗<del>以及我的鐵人賽挑戰</del>，所以最終才分成三篇。<br>另外，若有人看不懂本篇的內容的話，可以回頭從<a href="https://ithelp.ithome.com.tw/articles/10295580">OS overview</a>開始看起喔。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">行程及執行緒</a><br><a href="https://www.quora.com/Why-are-threads-considered-cheap">Why Thread Considered Cheap</a><br><a href="https://stackoverflow.com/questions/1897993/what-is-the-difference-between-concurrent-programming-and-parallel-programming">What is the difference between concurrent programming and parallel programming?</a><br><a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a><br><a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a><br><a href="https://hackmd.io/@sysprog/linux-process">Linux 核心設計: 不僅是個執行單元的 Process</a><br><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.geeksforgeeks.org/threads-and-its-types-in-operating-system/">Threads and its types in Operating System</a><br><a href="https://medium.com/@yovan/os-process-thread-user-kernel-%E7%AD%86%E8%A8%98-aa6e04d35002">OS Process &amp; Thread (user&#x2F;kernel) 筆記</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(下)-並發(concurrency)</title>
    <url>/code-blog/2022/09/24/OS_concurrency/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>並發Concurrency也是一個常在開發中聽到的名詞，他跟並行Parallel有什麼差別呢?他能夠給系統帶來什麼好處?又有什麼風險需要注意?我們常聽到js是個單執行緒的語言，這又是什麼意思?node.js是單執行緒嗎?</p>
<p>這就是今天會希望解答的問題，那就開始吧~</p>
<span id="more"></span>

<h2 id="Concurrency-vs-Parallel"><a href="#Concurrency-vs-Parallel" class="headerlink" title="Concurrency vs Parallel"></a>Concurrency vs Parallel</h2><p>雖然我們今天的主題談的是Concurrency(並發)，但通常會與Parallel(並行)作個比較。</p>
<p><img src="https://i.imgur.com/kPV2fk8.png"></p>
<p>這是我在找資料學習時最喜歡的一張圖，我覺得他比較正確的視覺化Concurrency及Parallel的定義及關係。<br>邊對照圖片，我們邊看這兩者的定義</p>
<ul>
<li>Concurrency: 多件事可以在一段時間內同時進行</li>
<li>Parallel: 有多件事可以在一個時間點同時進行</li>
</ul>
<p>看起來很像對吧，雖然兩邊都是講同時，但他們對於時間的粒度不太相同，我覺得用排除法去想這件事情比較容易:</p>
<blockquote>
<p>當我們在判斷現在是什麼狀況時，先看<strong>某一個瞬間</strong>可不可以有多個任務同時進行，有的話那就是Parallel；若否，再看<strong>一段時間軸</strong>內可不可以有多件事情同時進行，那就是Concurrency。</p>
</blockquote>
<p>這也是圖片說的，如果一個系統內可以作到Parallel，那他必定也是Concurrency。<br>另外從圖裡面的CPU的表示也能看到，一般而言(註1)一個CPU同時只能被分配給一個thread，在這個狀況下，只有多CPU的狀況才能出現Parallel，這也是為什麼今天我們只先討論Concurrency。</p>
<p>註1: 除非今天CPU支援Hyper-threading(超執行緒)。</p>
<h2 id="Multi-process-Multi-thread-都擠"><a href="#Multi-process-Multi-thread-都擠" class="headerlink" title="Multi process, Multi thread 都擠?"></a>Multi process, Multi thread 都擠?</h2><p>根據Concurrency的定義其實我們可以有兩種Concurrency的方法，一個是多執行緒，一個是多行程，他們都會有多個執行緒讓CPU得以分配時間在他們身上。<br>不過如果你有從昨天一路看下來，就會發現，多行程是一個非常大的成本花費，我們也可以有一個結論，基本上除非你希望資源被隔離得很徹底，不然在Concurrency上，我們應該盡可能使用多執行緒去作Concurrency。</p>
<p>這邊就有一個例子，大部分的web server在接受到新的request時，是不用等待前面的請求結束對吧?一般而言，都是建立thread去處理請求而非process，然後結束時就立刻把thread terminate。</p>
<p>再來我們試著用反例想想，如果我們是以建立process的方式來處理多請求同時出現會發生什麼狀況?<br>第一可能會在建立process就花一點時間，當處理完請求後，又會遇到一個難題是要不要把Process砍掉，如果砍掉下次建立又要花時間，但是不砍掉，他會霸佔部分記憶體資源無法使用，如果有某個請求需要超過原本的記憶體大小，就可能造成memory leak。</p>
<p>當然也有使用多Process的例子，根據這篇資料:</p>
<blockquote>
<p>Google had to decide how to handle that separation of tasks. They chose to run each browser window in Chrome as a separate process rather than a thread or many threads, as is common with other browsers.<br>– <a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/">What’s the Diff: Programs, Processes, and Threads</a></p>
</blockquote>
<p>Google決定選擇使用多進程的原因可以在內文詳看，但他們認為這可以減少最終對於記憶體的使用。</p>
<h2 id="並發的好處"><a href="#並發的好處" class="headerlink" title="並發的好處"></a>並發的好處</h2><p>於是我們可以來整理一下，使用並發的好處包括有什麼呢?(無論Process或是Thread)</p>
<ul>
<li>性能提升: 能夠做到並發的系統，多個Process在運行時的總時間 &lt;&#x3D;(註1) 順序運行Process的總時間。</li>
<li>多程式應付可能: 透過CPU scheduling可以讓系統體感像是多個程式在同時進行一樣。</li>
<li>資源利用: 減少CPU閒置。</li>
</ul>
<p>額外補充，若使用多Thread相對多Process處理並發的好處有什麼呢: </p>
<ul>
<li>Parallel的可能性: 我們前面談的是單核心處理多Thread的狀況，但如果假使是在一個多Processor(多核心、單核心超執行緒…等等)的架構中，經過規劃的多執行緒程式可以在一個時間點同時進行多個Thread的工作，讓並行得以發生。</li>
<li>專業化: 我們可以把工作分門別類產生多個Thread去處理特定工作，甚至可以管理Thread，像是可以去管理Thread的優先層級。</li>
<li>高效: 前面也提到過，Thread相對Process，建立成本低、資料分享容易、資源利用度高，這都是相對多Process高效的原因。</li>
</ul>
<p>註1: 假如這邊範例中的多個process都僅需要CPU運算，因為沒有速率差異導致的閒置問題，那執行併發跟順序執行，總時間都會相同。</p>
<h2 id="並發的風險"><a href="#並發的風險" class="headerlink" title="並發的風險"></a>並發的風險</h2><p>除了好處，事實上多執行緒有許多因為共用資源等特性產生的風險需要在開發時顧慮:</p>
<ul>
<li><p>競爭race condition:<br>正因為共用資料，當出現I&#x2F;O或其他不可控的時間或順序事情時，有可能導致順序依賴的錯誤。<br>例如: 有個變數x &#x3D; 3，兩個共用資源的程式可能有兩個操作 x &#x3D; x + 2, x &#x3D; x + 3，結果意外出現5或6，但原本預期最後結果要是8，想像這如果是你的存款XD<br>而且這樣的錯誤又相當難以追蹤，因為並沒有相關錯誤訊息~</p>
</li>
<li><p>死鎖dead lock:<br>當一個Process在等待其他Process釋放手上的資源時。<br>比如P1需要P0手上的disk資源，但此時P0因為讓出CPU給P1，以至於兩者都無法完成工作。</p>
</li>
<li><p>飢餓starvation:<br>當一個Process因為一直被剝奪完成工作需要的資源。<br>比如因為優先權演算法，P0因為其他優先權更高的Process不斷出現而遲遲拿不到CPU運算。</p>
</li>
</ul>
<p>他們最大的差異，死鎖是除非有額外的機制處理，不然兩者是永遠無法完成工作的；而飢餓則是有機會完成工作，只是不知道什麼時候才會完成。</p>
<h2 id="User-Thread-vs-Kernel-Thread"><a href="#User-Thread-vs-Kernel-Thread" class="headerlink" title="User Thread vs Kernel Thread"></a>User Thread vs Kernel Thread</h2><p>並發的內容看起來結束了，但看到這邊還有一長段你就會知道還沒有XD<br>事實上，大部分的操作系統為了介入一般應用程式及管理他們，他們會使用一個叫做Kernel的程式。<br>而這個Kernel也影響了多執行緒行程如何與操作系統工作，由此出現了user thread及kernel thread這兩個概念。<br>我覺得有個更好稱呼他們的方式是user-level thread及kernel-level thread。</p>
<p>於是在比較他們之前我們需要先了解什麼是Kernel及mode。</p>
<h3 id="Kernel-是什麼"><a href="#Kernel-是什麼" class="headerlink" title="Kernel 是什麼?"></a>Kernel 是什麼?</h3><p>所以究竟Kernel是什麼，他產生thread的原因是什麼呢?</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8f/Kernel_Layout.svg"><br>他其實也是一個系統中的一個具有足夠優先權限的Process，負責處理其他Process與硬體之間的溝通。<br>需要他的原因在於與硬體溝通是相當複雜的，他提供了介面讓硬體操作被抽象化。</p>
<blockquote>
<p>嚴格地說，核心並不是電腦系統中必要的組成部分。有些程式可以直接地被調入電腦中執行；這樣的設計，說明了設計者不希望提供任何硬體抽象和作業系統的支援<br>– <a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">維基百科</a></p>
</blockquote>
<p>Kernel會在其他任何Process被載入，讓操作系統得以介入每個Process，這個介入就是讓User-level Thread與Kernel-level Thread綁定在一起。<br>而當User-level Thread需要與硬體溝通，他就會先與Kernel-level Thread溝通，</p>
<h3 id="Kernel-Mode-vs-User-Mode"><a href="#Kernel-Mode-vs-User-Mode" class="headerlink" title="Kernel Mode vs User Mode"></a>Kernel Mode vs User Mode</h3><p>我把他理解成是兩種不同的權限，為什麼需要兩種特權呢?</p>
<blockquote>
<p>為了避免一個使用者的程式修改其他使用者的程式甚至是系統核心， 並且更進一步，讓作業系統可以壟斷所有的硬體資源，大部分的機器(或者 CPU)至少會有二個執行特權(privilege)：Kernel mode (又稱 System mode) 與 User mode。<br>– <a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a></p>
</blockquote>
<p>既然知道這兩者模式的差異，那又跟Kernel有什麼關係呢?</p>
<blockquote>
<p>Kernel mode is the CPU’s “natural” mode, with no restrictions (on x86 CPUS - “ring 0”). User mode (on x86 CPUs - “ring 3”) is when the CPU is instructed to trigger an interrupt whenever certain instructions are used or whenever some memory locations are accessed. This allows the kernel to have the CPU execute specific kernel code when the user tries to access kernel memory or memory representing I&#x2F;O ports or hardware memory such as the GPU’s frame buffer.<br>– <a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a></p>
</blockquote>
<p>大概意思是，在程式要求執行一些動作時，若他不具有特定權限，Kernel也能夠去要求CPU執行一些相對的Kernel code去中斷目前的Process。<br>這樣讓開發者少掉維護或檢查影響到其他的程式的壓力跟錯誤。</p>
<p>如果是web後端，用最優先的middleware來理解Kernel是不是會容易些?</p>
<h3 id="User-Thread-x2F-User-level-Thread"><a href="#User-Thread-x2F-User-level-Thread" class="headerlink" title="User Thread &#x2F; User-level Thread"></a>User Thread &#x2F; User-level Thread</h3><p>擁有user mode權限的thread，透過特定介面的library建立的，OS並不知道他們的存在，但在要工作時，會mapping到Kernel thread上。<br>特性: </p>
<ul>
<li>產生、管理的成本低</li>
<li>舉例像是: POSIX Pthreads, Win32 threads, Java threads</li>
</ul>
<h3 id="Kernel-Thread-x2F-Kernel-level-Thread"><a href="#Kernel-Thread-x2F-Kernel-level-Thread" class="headerlink" title="Kernel Thread &#x2F; Kernel-level Thread"></a>Kernel Thread &#x2F; Kernel-level Thread</h3><p>僅運行kernel code且與user space(memory) process毫無關聯的Thread。<br>並且我們知道thread一定在process之中，而Kernel thread就是Kernel這個Process產生出來的thread</p>
<ul>
<li>CPU能查覺到存在的其實是Kernel-level Thread，而非mapping於他的User-level Thread。</li>
<li>舉例像是: Windows 2000(NT), Solaris, Linux</li>
</ul>
<h2 id="多執行緒模式"><a href="#多執行緒模式" class="headerlink" title="多執行緒模式"></a>多執行緒模式</h2><p>由上，我們會知道，所以在user mode的Process要操作到硬體的部分是需要經過kernel thread。<br>而這個對映的方式稱為mapping，mapping的方式共有三種:</p>
<ul>
<li>多對一</li>
<li>一對一</li>
<li>多對多</li>
</ul>
<h3 id="多對一"><a href="#多對一" class="headerlink" title="多對一"></a>多對一</h3><p><img src="https://i.imgur.com/Sd5bMmQ.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到一個Kernel-level Thread</li>
<li>優點:<ul>
<li>Thread管理在user space(memory)完成，效率高</li>
</ul>
</li>
<li>缺點:<ul>
<li>整個process可能會因為其中一個user thread發出的指令而導致block。</li>
<li>因為OS僅察覺到一個kernel thread，如果在一個以thread數量平分cpu使用使間的系統中，他的單位仍是一。</li>
<li>只有一個thread可以訪問kernel，就算是多processor的環境也無法平行。</li>
</ul>
</li>
</ul>
<h3 id="一對一"><a href="#一對一" class="headerlink" title="一對一"></a>一對一</h3><p><img src="https://i.imgur.com/IxbwdDb.png"></p>
<ul>
<li>定義: 一個User-level Thread mapping到一個Kernel-level Thread</li>
<li>例子: Linux, Windows XP&#x2F;NT&#x2F;2000</li>
<li>優點:<ul>
<li>所有多對一的缺點的相反。</li>
</ul>
</li>
<li>缺點:<ul>
<li>產生一個thread時就同時產生kernel thread，負擔較高</li>
<li>所有的操作都會進行system call，要進行前者的動作，需要將權限改為kernel mode，而這是一個昂貴的操作</li>
</ul>
</li>
</ul>
<h3 id="一對多"><a href="#一對多" class="headerlink" title="一對多"></a>一對多</h3><p><img src="https://i.imgur.com/SHSoik1.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到多個Kernel-level Thread</li>
<li>優點:<ul>
<li>可在多Processor系統中平行執行。</li>
<li>某個thread被block後可安排其他kernel thread執行</li>
</ul>
</li>
<li>缺點:<ul>
<li>需要user thread 管理器與 kernel thread 管理器支援這種協調。</li>
</ul>
</li>
</ul>
<h2 id="node-js的有趣事實"><a href="#node-js的有趣事實" class="headerlink" title="node.js的有趣事實"></a>node.js的有趣事實</h2><p>關於node.js，他究竟是不是單執行緒的runtime呢?<br>他像是，但其實並不是的。<br>他一共有7個執行緒，包括1個執行JS的主執行緒、4個node.js執行緒、2個V8執行緒。</p>
<h3 id="調查多執行緒的事實"><a href="#調查多執行緒的事實" class="headerlink" title="調查多執行緒的事實"></a>調查多執行緒的事實</h3><p>要證明這件事情其實意外的容易:</p>
<ol>
<li>先做一個可以永久執行的node.js，例如web server或是無限while迴圈之類的</li>
<li>取得PID<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps | grep node</span><br></pre></td></tr></table></figure></li>
<li>查看執行緒<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br><span class="line"># -H可以顯示行程中的執行緒</span><br><span class="line"># -P指定特定PID</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你就可以看到7個執行緒了<br>不過4個node.js的執行緒其實只會做I&#x2F;O相關的工作，如果遇到CPU密集的工作，其實還是會發生JS主執行緒阻塞而導致整個Process阻塞的狀況。</p>
<h3 id="worker-threads-module"><a href="#worker-threads-module" class="headerlink" title="worker-threads module"></a>worker-threads module</h3><p>node.js v12開始支援worker-threads，於是剛剛提到的CPU密集型的工作就可以透過模組建立新的thread去承接這個工作。<br>詳細有興趣的人可以去<a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js"></a>跟著教學一起玩一下，蠻有意思的喔!</p>
<h3 id="cluster-module"><a href="#cluster-module" class="headerlink" title="cluster module"></a>cluster module</h3><p>cluster則是支援建立主Process的child processes，而官方的資料也確實提到，若沒有隔離行程的必要，就使用worker-threads代替。</p>
<blockquote>
<p>Clusters of Node.js processes can be used to run multiple instances of Node.js that can distribute workloads among their application threads. When process isolation is not needed, use the worker_threads module instead, which allows running multiple application threads within a single Node.js instance.<br><a href="https://nodejs.org/api/cluster.html">node.js</a></p>
</blockquote>
<p>不過根據官方文件以及在實務上看到cluster的用法，cluster更像是一種負載平衡的機制，worker-threads則可以用來應付CPU密集的工作，所以我覺得完全有可能混用他們!</p>
<p>也確實有stackoverflow的回答這樣認為~</p>
<blockquote>
<p>Which is better? It depends on the problem you’re solving. Worker threads are for long-running functions. Clustering makes a server able to handle more requests, by handling them in parallel. You can use both if you need to: have each nodejs cluster process use a worker thread for long-running functions.<br><a href="https://stackoverflow.com/questions/61328960/when-is-better-using-clustering-or-worker-threads">When is better using clustering or worker_threads?</a></p>
</blockquote>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然寫的辛苦，但總算對於Program、Process、Thread有了更進一步的了解。<br>而且回過頭來，我覺得這樣我在使用一些與Thread以及Process相關的功能時也能更有把握些。<br>想起第一次面試時，當時考官就問我node.js是否是單執行緒這個問題，結果直到今天我才有辦法稍稍好一點的回答這個問題XD</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>發現我用了一些中文單字其實是有中、台兩種說法的，參照<a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">此篇</a>特意列出，避免混淆。</p>
<ul>
<li>concurrent:<ul>
<li>台灣：並行</li>
<li>大陸：並發</li>
</ul>
</li>
<li>parallel:<ul>
<li>台灣：平行</li>
<li>大陸：並行</li>
</ul>
</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.kshuang.xyz/doku.php/operating_system:course_concept:thread">Thread</a><br><a href="https://hackmd.io/@Chang-Chia-Chi/OS-CH4">作業系統 CH4 Multithreaded Programming</a><br><a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">Difference between user-level and kernel-supported threads?</a><br><a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">核心</a><br><a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a><br><a href="https://medium.com/@akhandmishra/operating-system-threads-and-concurrency-aec2036b90f8">Operating System: Threads and Concurrency</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js">https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js</a><br><a href="https://blog.appsignal.com/2021/02/03/improving-node-application-performance-with-clustering.html">Improving Node.js Application Performance With Clustering</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>我叫雜湊不叫加密-hashing (MD5, SHA family, scrpty, bcrypt)</title>
    <url>/code-blog/2022/10/06/Secret_Hash/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在聊到JWT的組成時有提到要將header跟payload做「雜湊」產生signature。</p>
<p>那到底雜湊是什麼呢?跟加密一樣嗎?</p>
<p>今天來了解一下!</p>
<span id="more"></span>

<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="什麼是加密"><a href="#什麼是加密" class="headerlink" title="什麼是加密?"></a>什麼是加密?</h3><p>加密指的是: </p>
<blockquote>
<p>將明文資訊改變為難以讀取的密文內容，使之不可讀的過程。<br>– <a href="https://zh.wikipedia.org/zh-tw/%E5%8A%A0%E5%AF%86">加密</a></p>
</blockquote>
<p>我覺得加密很像是把東西加上一把鎖，有鑰匙就可以進去資料的裡面。</p>
<p>加密的特性:</p>
<ul>
<li>可逆: 可以經過特定演算法加上必要條件(例如: 金鑰)後還原回加密前的原始資料。</li>
</ul>
<h3 id="分類"><a href="#分類" class="headerlink" title="分類"></a>分類</h3><p>加密演算法一般可以分為兩類</p>
<ul>
<li>對稱加密: 加解密皆使用相同金鑰</li>
<li>非對稱加密&#x2F;公鑰加密: 加密會使用公鑰，解密會使用私鑰</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>重點在於這個被加密的資料是還需要被指定的對象閱讀的，所以適合用在資料傳輸中。</p>
<h2 id="雜湊"><a href="#雜湊" class="headerlink" title="雜湊"></a>雜湊</h2><h3 id="什麼是雜湊"><a href="#什麼是雜湊" class="headerlink" title="什麼是雜湊?"></a>什麼是雜湊?</h3><p>當我們提到雜湊時，其實是指說，將一些資料輸入到雜湊演算法，並取得經過雜湊演算法而有的新資料。</p>
<blockquote>
<p>是一種從任何一種資料中建立小的數字「指紋」的方法。雜湊函式把訊息或資料壓縮成摘要，使得資料量變小，將資料的格式固定下來。該函式將資料打亂混合，重新建立一個叫做雜湊值（hash values，hash codes，hash sums，或hashes）的指紋。<br>– <a href="https://zh.wikipedia.org/zh-tw/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">維基百科</a></p>
</blockquote>
<p>雜湊有幾個特性:</p>
<ul>
<li>輸出固定長度</li>
<li>不可逆: 無法透過雜湊函式回算原本的輸入</li>
<li>資料壓縮</li>
<li>相同內容輸入同一雜湊函式會得到相同的雜湊值</li>
<li>不同內容輸入同一雜湊函式得到相同雜湊值極低，若出現相同會稱為「碰撞Collision」</li>
</ul>
<h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><ul>
<li>資料保護&#x2F;驗證: 因為資料在雜湊後能得到接近唯一值，可以用來檢查資料是否被修改。</li>
<li>錯誤校正</li>
</ul>
<p>總而言之，有些資料是不必還原的，我們僅需要透過這些資料的「特徵」以確認資料有沒有被改變。</p>
<h3 id="簡介常見的加密及雜湊演算法"><a href="#簡介常見的加密及雜湊演算法" class="headerlink" title="簡介常見的加密及雜湊演算法"></a>簡介常見的加密及雜湊演算法</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>是一種雜湊演算法，輸入不固定長度後，可以產出固定128-bits雜湊值。<br>在90年代時被廣泛運用，不過在2009年，有人用了一種碰撞演算法，可以在一般電腦執行數秒即可完成的複雜度之下完成碰撞。<br>故2011年，此演算法在RFC6151中被禁止用作金鑰雜湊訊息鑑別碼。</p>
<p>除此之外，他的危險來自於:</p>
<ul>
<li>MD5的暴力硬解很快，</li>
<li>因為被廣泛使用，所以他的字典裡的資料所對應已經儲存了相當大量，可參考MD5 Online</li>
</ul>
<h4 id="SHA-Family"><a href="#SHA-Family" class="headerlink" title="SHA Family"></a>SHA Family</h4><p>是一系列雜湊演算法的統稱，包括SHA-0, SHA-1, SHA-2(是SHA-224, SHA-256…SHA-512的統稱), SHA-3等。</p>
<p><img src="https://i.imgur.com/0R6oa62.png" alt="圖 11">  </p>
<p>根據資料，目前SHA-0已經淘汰, 而SHA-1也已經被列為弱安全性，目前較常使用的是SHA-256。</p>
<h4 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h4><p>可以說是專門用於密碼的慢雜湊演算法，除了可以加鹽來抵抗彩虹表攻擊外，因為他可以保證加密的速度落在一個特定範圍內，所以可以延長攻擊方的加密速度，讓暴力搜尋變得比較容易被防禦。</p>
<h4 id="scrypt"><a href="#scrypt" class="headerlink" title="scrypt"></a>scrypt</h4><p>記憶體依賴的雜湊演算法，目前常用於區塊鏈。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>大致了解演算法的種類，對於什麼情境常用到的演算法可以有些認識了。</p>
<p>有時候其實也是會混合使用的，比如說，可能會先將資料加密，再將資料做雜湊給對方一個雜湊值以驗證資料有沒有經過竄改等等，都是一些常用的作法。</p>
<p>有一個資料裡提到的結論蠻好的，引用一下:</p>
<blockquote>
<p>在資安領域沒有所謂絕對的安全，你只能不斷提高攻擊者的成本，當那個成本高到攻擊者無法負荷時（像是破解一個密碼要租超級電腦連續計算十年），那就可以說是足夠安全了XD<br>– <a href="https://medium.com/starbugs/how-to-store-password-in-database-sefely-6b20f48def92">聽說不能用明文存密碼，那到底該怎麼存？</a></p>
</blockquote>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10208884">[資料結構] 雜湊 (Hash)</a><br><a href="https://dotblogs.com.tw/regionbbs/2017/09/21/hashing_is_not_encryption">[Security] 雜湊不是加密，雜湊不是加密，雜湊不是加密。</a><br><a href="https://medium.com/@RiverChan/%E5%9F%BA%E7%A4%8E%E5%AF%86%E7%A2%BC%E5%AD%B8-%E5%B0%8D%E7%A8%B1%E5%BC%8F%E8%88%87%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86%E6%8A%80%E8%A1%93-de25fd5fa537">基礎密碼學(對稱式與非對稱式加密技術)</a><br><a href="https://www.zhihu.com/question/21668719/answer/2159366643">先用md5，再用sha1，这样密码会安全一点吗？</a><br><a href="https://www.796t.com/content/1548055091.html">scrypt演算法的前世今生（從零開始學區塊鏈 192）</a><br><a href="https://medium.com/starbugs/how-to-store-password-in-database-sefely-6b20f48def92">聽說不能用明文存密碼，那到底該怎麼存？</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Hash</tag>
        <tag>MD5</tag>
        <tag>SHA</tag>
      </tags>
  </entry>
  <entry>
    <title>就是快取啦-Cache</title>
    <url>/code-blog/2022/10/05/Web_Cache/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現代Web最影響使用者是否使用服務的其中一項重大因素來自於服務響應使用者互動的速度。</p>
<p>白話的意思就是說點開網站內的內容有多快，就有多影響使用者體驗。</p>
<p>影響服務響應的原因可能很多，但大檔案或是常用的資料不斷重複的在服務之間流通絕對是影響速度的其中一大原因，因此為了解決這樣的服務瓶頸，出現了一個概念: Cache(緩存&#x2F;快取)。</p>
<p>這也是今天要介紹的部分，那就開始吧~</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>將常用的資料儲存在本地memory(較快的元件(註1))中一段時間以取代從較慢元件取得資料的相關技術。</p>
<p>這樣，當其他人需要請求相同的資料時，就不需要額外進行網路傳輸、資料庫提取等動作，可以直接從memory中取得資料，以加快響應速度。</p>
<p>這個概念可以擴及到所有面臨瓶頸的服務身上，因為所有服務都有構成他相對有快、慢差異的元件。</p>
<p>舉例來說我們的電腦就有memory及disk，如果OS在處理服務的過程，有一項技術是將常用的資料也放在memory，而不每次都從disk取得，這其實就是一個Cache的概念。</p>
<p>回到Web溝通的層面，當Client和Server溝通時，常見的像是瀏覽器與提供網頁服務的瀏覽器，相對快、慢的元件可能是本地儲存、遠端服務db，於是將常訪問的網站資料儲存在瀏覽器預先設定的空間，就算是disk內，也可以說這樣是一種Cache。</p>
<p>接下來會列出幾項在Web中常見的不同層次的瓶頸以及相對應實現Cache的技術。</p>
<ul>
<li>Browser layer: Browser Storage</li>
<li>Server layer: Redis</li>
<li>Client layer: CDN</li>
</ul>
<h2 id="Browser-layer-Browser-Storage"><a href="#Browser-layer-Browser-Storage" class="headerlink" title="Browser layer: Browser Storage"></a>Browser layer: Browser Storage</h2><h3 id="快、慢元件"><a href="#快、慢元件" class="headerlink" title="快、慢元件"></a>快、慢元件</h3><p>在瀏覽器與提供網頁瀏覽的Server交互時</p>
<ul>
<li>快: 本地的儲存裝置</li>
<li>慢: 經過HTTP取得的資料</li>
</ul>
<h3 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h3><p>大部分的瀏覽器都支援以下的方案: </p>
<ul>
<li>HTTP Cache<br>瀏覽器每次發送Request前會先檢查Header裡的 <code>Cache-Control: no-cache, max-age=...</code> ，若在特定條件下可以不發出任何request。</li>
</ul>
<p>根據<a href="https://web.dev/http-cache/">資料</a>，下圖是Cache-Control的決策圖，黃底代表決定使用哪個參數。<br><img src="https://i.imgur.com/ywXHNlb.png" alt="圖 10">  </p>
<ul>
<li>Data Store<br>在執行網頁時，藉由瀏覽器的API介面，透過JS去儲存、提取資料，其儲存的位置包含: Cookie、Web Storage、IndexedDB。</li>
</ul>
<p>未來可能會有Cache的API，目前還在實驗中~</p>
<h2 id="Server-layer-Redis、Memcached"><a href="#Server-layer-Redis、Memcached" class="headerlink" title="Server layer: Redis、Memcached"></a>Server layer: Redis、Memcached</h2><h3 id="快、慢元件-1"><a href="#快、慢元件-1" class="headerlink" title="快、慢元件"></a>快、慢元件</h3><p>為了取得Client需要的資料，可能有與DB、或是其他服務溝通的必要</p>
<ul>
<li>慢: Server的DB或其他提供服務的Server</li>
<li>快: Server的Memory</li>
</ul>
<h3 id="解決方案-1"><a href="#解決方案-1" class="headerlink" title="解決方案"></a>解決方案</h3><p>為了方便開發者使用Server的Memory，因此出現了以下兩種解決方案:</p>
<ul>
<li>Redis</li>
</ul>
<p>之前在NoSQL DB介紹過，key-value的DB，可以讓使用者快速的利用Memory，且支援許多data-type，並且提供一種類似快照(Snap Shot)的功能，讓儲存在Redis的資料可以回存其他DB。</p>
<p>另外因為她支援套件，可以讓Redis得以處理類似關聯式的資料，或是JSON類型的資料，因此官方也宣稱他足以作為主DB來使用。</p>
<ul>
<li>Memcached</li>
</ul>
<p>multi-thread &amp; simple string data type，雖然data的種類限制了它的使用，但他的設計一開始就是為了減少DB或是API的壓力，於是若是在特定條件下也是一種方案</p>
<h2 id="Client-layer-CDN"><a href="#Client-layer-CDN" class="headerlink" title="Client layer: CDN"></a>Client layer: CDN</h2><h3 id="快、慢元件-2"><a href="#快、慢元件-2" class="headerlink" title="快、慢元件"></a>快、慢元件</h3><p>全名是Content delivery network內容傳遞網路，他的情境與Browser layer Cache有點類似，但這裡的CDN是所有的Client都可以享受到好處的，他在意的情境除了網路傳輸的速度，更是提供服務的主機與Client的距離導致的傳輸延遲。</p>
<ul>
<li>慢: 較遠的Source Service Server(提供服務的伺服器)</li>
<li>快: 較近的CDN Server</li>
</ul>
<p>按照這裡提到的，Browser除了可以使用Browser Cache把資料放在本地，也可以在request時使用CDN嘗試獲取比較近的資源。</p>
<h3 id="解決方案-2"><a href="#解決方案-2" class="headerlink" title="解決方案"></a>解決方案</h3><p>本身就是解決方案，他期望做到的是，透過利用最靠近使用者的CDN Server，將從Source Service Server取得的資料，像是音樂、圖片、影片等，在CDN Server保留資料，並較快的提供給使用者。</p>
<p>它的運作模式大部分也是依賴由Source Server提供的response內的 <code>cache-control</code> Header去做控制。</p>
<p>除此之外廠商可能會提供API讓Source Server可以在資料被更新時主動更新CDN Server裡面的資料及相關回傳給Client的Header。</p>
<p><img src="https://i.imgur.com/KPcLq4a.png" alt="圖 9">  </p>
<h3 id="額外好處"><a href="#額外好處" class="headerlink" title="額外好處"></a>額外好處</h3><p>除了加快資源取得的速度，他也包含幾項好處</p>
<ul>
<li>減少用戶網路流量: 網路流量對使用者來說都是成本，不是全世界都有像台灣一樣吃到飽XD</li>
<li>減少Source Server負擔: 因為減少了訪問Server次數及流量</li>
<li>提高安全性: 舉例來說如果遭到DDoS攻擊，若CDN供應商有提供相關服務可以阻擋，若沒有，至少有一部份的攻擊會被CDN代替承受…XD</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>最主要了解Cache是基於組成服務的元件的速度不一致，其中一個就會成為瓶頸，因此將常用的資料儲存在較快的元件上可以減少訪問慢速元件的次數提升體驗。</p>
<p>於是我們可以大膽猜測，如果哪天遠端服務響應的素快於本地硬體儲存的速度，這時候的Cache就會反過來儲存在遠端服務上了吧XD</p>
<p>我覺得保留Cache的概念，並知道如何分析瓶頸元件，就足以應付後面的變化，各樣的技術&#x2F;解決方案無非也是為了解決當前遇到的問題。</p>
<p>此文章同步發表於<a href="https://tim80411.github.io/code-blog/">部落格</a>，歡迎來逛逛～</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://hsien-w-wei.medium.com/front-end-browser-cache-%E7%86%9F%E6%82%89%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA-i-5e1f76a4713d">[Front-end] Browser Cache : 熟悉的陌生人 I</a><br><a href="https://pjchender.dev/webdev/note-http-cache/">[note] HTTP Cache 快取</a><br><a href="https://web.dev/http-cache/">使用 HTTP 缓存避免不必要的网络请求</a><br><a href="https://www.youtube.com/watch?v=G1rOthIU-uo&ab_channel=Fireship">Redis in 100 Seconds</a><br><a href="https://medium.com/jerrynotes/redis-vs-memcached-%E6%AF%94%E8%BC%83-15d2ba829da7">Redis vs Memcached 比較</a><br><a href="https://mgleon08.github.io/blog/2018/10/29/understand-cdn/">簡單理解 CDN 原理</a><br><a href="https://www.cloudflare.com/en-ca/learning/cdn/what-is-a-cdn/">什麼是 CDN？| CDN 是如何工作的？</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>Backend</tag>
        <tag>Cache</tag>
        <tag>CDN</tag>
        <tag>Redis</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
</search>
