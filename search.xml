<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>電腦與外界的通訊方式-輸入/輸出(I/O)管理</title>
    <url>/code-blog/2022/09/27/OS_IO/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>許多Process的執行除了依賴CPU的運算及Memory的儲存，也依賴於其他設備，其中一部分專門用於接受使用者輸入及引導輸出的設備，被稱為I&#x2F;O設備，I&#x2F;O就是input及output的簡稱。</p>
<p>透過今天的內容，會稍微了解IO管理的設計，以及是透過什麼方式整合IO設備與CPU的溝通。</p>
<span id="more"></span>

<h2 id="IO管理的目標"><a href="#IO管理的目標" class="headerlink" title="IO管理的目標"></a>IO管理的目標</h2><ul>
<li>易用: 方便用戶使用</li>
<li>效率: 提高系統的併發工作能力</li>
<li>防錯: 增加設備的可靠及安全性</li>
</ul>
<h2 id="IO流程"><a href="#IO流程" class="headerlink" title="IO流程"></a>IO流程</h2><p>當系統發出指令需要執行IO功能時的流程是什麼呢?<br>我後來發現先大概看一下流程有個全觀的認識，後面了解起來會比較清楚。</p>
<p>以下資料來自<a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">Day-17 I&#x2F;O運作</a></p>
<table>
<thead>
<tr>
<th align="left">流程</th>
<th align="left">動作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">User process發出I&#x2F;O request給OS</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">OS收到請求，可能暫停此process執行，並執行相對應的system calls。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">kernel的I&#x2F;O-subsystem會pass此請求給<strong>Device driver</strong>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Device driver依此請求設定對應的I&#x2F;O commands參數給<strong>Device Controller</strong>。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Device Controller啟動，監督I&#x2F;O-Device之I&#x2F;O運作進行。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">在此時，OS可能將CPU切給另外一個process執行。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">後續步驟根據<strong>IO控制方式</strong>。</td>
</tr>
</tbody></table>
<p>後面在介紹各個粗體的字詞後，我覺得對IO就會有個基本的認識了</p>
<h2 id="控制器Registers"><a href="#控制器Registers" class="headerlink" title="控制器Registers"></a>控制器Registers</h2><p>為了達到模組化及通用，一般會將IO區分為機械、電子兩個部分，機械通常是IO設備功能本體，而電子的部分會是用來連接系統的一塊主機板，稱作。</p>
<p><img src="https://i.imgur.com/UJtbyjM.png"><br>控制器包含三個重要的部分:</p>
<ul>
<li>Command Register: 存放CPU所呼叫的命令，讓CPU控制裝置。</li>
<li>Status Register: 存放CPU傳來的狀態資訊，讓CPU了解裝置狀態。</li>
<li>Data Register: 存放預備輸入或輸出的資料</li>
</ul>
<p>透過這三個控制器，操作系統簡化了開發不同設備的介面，有點像是操作系統預先設定好幾個標準介面要求IO設備去符合他們，好處是操作系統開發起來省力，並且可以提高設備的擴充性。</p>
<p>換個角度想就是，如果各家IO設備都有自己的API要求系統去處理，一是會累死系統開發人員，二是這樣就要等到系統支援才有辦法讓IO設備被系統使用。</p>
<h2 id="IO控制"><a href="#IO控制" class="headerlink" title="IO控制"></a>IO控制</h2><p>我自己是根據CPU介入的程度來分為以下4種:</p>
<ol>
<li>Process直接控制</li>
<li>Polling I&#x2F;O</li>
<li>Interrputed I&#x2F;O</li>
<li>DMA I&#x2F;O</li>
</ol>
<h3 id="Process直接控制"><a href="#Process直接控制" class="headerlink" title="Process直接控制"></a>Process直接控制</h3><p>直接由Process控制IO，優點是簡單易實現，缺點就是在IO傳輸時，CPU也被迫閒置等待。</p>
<h3 id="Polling-I-x2F-O"><a href="#Polling-I-x2F-O" class="headerlink" title="Polling I&#x2F;O"></a>Polling I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，在執行其他Process時會在完成指令週期時去輪詢polling裝置控制器確認是否完成。</p>
<p>因為CPU會有polling的成本，等於擠壓到執行Process的時間，適合Device執行速度的狀況，不然每次執行週期可能會需要輪詢過多device。</p>
<h3 id="Interrputed-I-x2F-O"><a href="#Interrputed-I-x2F-O" class="headerlink" title="Interrputed I&#x2F;O"></a>Interrputed I&#x2F;O</h3><p>CPU 發出命令去執行IO功能後，IO會在執行完畢後發出中斷指令，系統一樣在完成指令週期時做檢查，不管變成僅檢查中斷指令。</p>
<p>和Polling的差異在IO是否會發出中斷指令，CPU是否能夠處理，若支援這樣的機制，好處是CPU可以減少輪詢時間。</p>
<h3 id="DMA-I-x2F-O"><a href="#DMA-I-x2F-O" class="headerlink" title="DMA I&#x2F;O"></a>DMA I&#x2F;O</h3><p>透過建立一個直接的數據通路，以及授權讓一個DMA控制器對數據通路有存取的權力，使得CPU自由~~~</p>
<p>控制方式是，CPU在需要IO功能時授權DMA控制器，DMA會自行與IO溝通，並將所有工作完成，並且因為有一個直接的數據通道，DMA連數據傳輸也會處理，否則像Interrputed I&#x2F;O仍需要由CPU處理數據，並發出中斷命令給CPU，CPU需要參與的部分僅在IO功能的開始及結束。</p>
<p>優點是因為解放CPU，CPU的使用率大幅提升，但因為數據通道直接放在Memory，DMA會跟CPU搶Memory的使用權。</p>
<h2 id="硬體驅動程式"><a href="#硬體驅動程式" class="headerlink" title="硬體驅動程式"></a>硬體驅動程式</h2><p>除了controller，IO中另外一環重要的部分為device driver。</p>
<p>驅動程式負責理解系統對IO設備發出的指令，並轉化成IO硬體能理解的內容以執行工作。</p>
<p>根據以下這張圖，應該可以更清楚device driver跟device controller之間的關係。</p>
<p><img src="https://i.imgur.com/9kvjQpK.png"></p>
<p>剛好回頭對照前面IO功能在執行時的流程圖<br>system call被呼叫時，指令會透過kernel傳給device driver，在透過device driver將指令轉化成IO controller能理解的形式並傳送過去。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天就這樣啦~<br>明天會來看看關於Unix的標準-POSIX。</p>
<p>此文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/27/OS_IO/">部落格</a>，歡迎來逛逛喔~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/23.html">IO核心子系統</a><br><a href="https://www.omscs-notes.com/operating-systems/io-management/">IO Management</a><br><a href="https://ithelp.ithome.com.tw/articles/10274340?sc=iThelpR">IO運作</a><br><a href="https://www.quora.com/What-is-the-difference-between-device-driver-and-device-controllers">What-is-the-difference-between-device-driver-and-device-controllers</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>行程間通訊(Inter Process Communication)</title>
    <url>/code-blog/2022/09/25/OS_Inter_Process_Communication/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在系統內，Process或是Thread若需要與其他合作，就須要有溝通的方式，而溝通的原因包括資料分享需要、模組…等等，這些就被稱為行程間通訊。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>多個 process&#x2F;thread 內部要去溝通，都統稱叫做 IPC。</p>
<p>關於這點我曾經有點困惑，為什麼Thread之間的溝通也被稱為行程間通訊，我個人給他的解釋是，因為Thread本身也可以算是一個Process，只是跟其他同Process的Thread共享了部分記憶體空間。</p>
<p><del>不過說不定只是那時候的人取錯名字了?</del></p>
<h2 id="情境需要"><a href="#情境需要" class="headerlink" title="情境需要"></a>情境需要</h2><ul>
<li>資訊分享: node.js經過cluster產生的child process和main process需要溝通。</li>
<li>加速運算: Parallel</li>
<li>模組化</li>
<li>方便</li>
</ul>
<h2 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h2><ul>
<li>Shared Memory</li>
<li>Message Passing</li>
</ul>
<h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>共享記憶體以進行通訊，使用時不需要kernel。<br>不過若是兩個Process之間想要使用這個方式進行通訊會因為需要額外建立共享的memeory區塊而發出system call了。</p>
<h2 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h2><p>要實現這個通訊方式，必須包含</p>
<ul>
<li>溝通方法: send &amp; receive</li>
<li>溝通管道</li>
</ul>
<p>在有些資料中，雖然會將IPC分為更多類，不過我最後根據<a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ipc</a>這份資料，認為理解他們的方式應視為在討論Message Passing實踐時的相異之處。</p>
<p>其中包括討論:</p>
<ul>
<li>溝通管道如何被建立?<br>通常會討論是直接通訊Direct Communication或是間接通訊Indirect Communication。</li>
<li>一個管道是否可以與兩個以上的Process有關?</li>
<li>Process與Process之間可以有多少管道?</li>
<li>管道的容量有多少?可容納的訊息是固定還是可變的</li>
<li>管道是雙向還是單向的</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>看了資料後才發現其實IPC蠻靠近我們的<br>包括我們在shell裡面常用的pipe</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find a | xargs grep &#x27;something&#x27;</span><br></pre></td></tr></table></figure>
<p>因為每個指令是一個process，前指令在將結果傳給後指令接收時使用的就是IPC。</p>
<p>另外瀏覽器請求server的通信也是。<br>不過IPC的細節實在太燒腦了，差點寫不完只好先停在這裡，若之後真的有機會再回頭來更新吧。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><!-- Tanenbaum & Bos 的Modern Operating Systems -->
<p><a href="https://hackmd.io/@YiZjennnnn/OS_Note/https%3A%2F%2Fhackmd.io%2F%40YiZjennnnn%2Fipc_interprocess_communication?type=book">IPC (Interprocess Communication)</a><br><a href="https://www.geeksforgeeks.org/inter-process-communication-ipc/">inter-process-communication-ip</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix的標準-POSIX Basics</title>
    <url>/code-blog/2022/09/28/OS_POSIX_Basics/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>POSIX到底是什麼神秘的東西呢?老實說，在roadMap提到這個單字前，我是真的完全不知道他是什麼XD</p>
<p>其實他就是一種interface的標準，為了要讓作業系統之間的相容性提高，所以符合POSIX的應用程式都會有一個重要的特性是:</p>
<blockquote>
<p>應該要能與其他符合POSIX標準的作業系統相容</p>
</blockquote>
<p>於是今天會講到一些歷史，並提到關於POSIX具有移植性的一些原因。</p>
<span id="more"></span>

<h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>有人說他的全稱是Portable Operating System Interface，並且最後加上X代表Unix，不過官方似乎也沒針對名字的全稱給出解釋。<br>他是由IEEE制定的，並且符合此標準的應用程式應該具有如前言所說的特性。</p>
<p>也因為這樣，在Linux及類Unix系統上多數工具的行為會幾乎相同。<br>這邊為什麼會將Linux與Unix分開說呢?<br>因為Linux雖然是根據大部分的POSIX的標準實現的，但他是從頭開發的，所以根本上他並不與Unix有實質的關聯。</p>
<h2 id="歷史小故事"><a href="#歷史小故事" class="headerlink" title="歷史小故事"></a>歷史小故事</h2><p>Unix在1974年由貝爾實驗室對外發布，自此開始出現了多個版本，並也有Unix廠商試圖加上一些不相容的特性來讓系統與其他有所區隔。<br>而後，為了提高相容性及應用程式的可移植性，IEEE開始著手將Unix的開發標準化，後由Richard Stallman命名為”POSIX”。</p>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>這邊會談到為什麼遵循POSIX就代表具有可移植性。<br>基本上作業系統有兩種方式可以跟硬體溝通:</p>
<ol>
<li>system call</li>
<li>library function</li>
</ol>
<h3 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h3><p>由作業系統提供給Process的溝通介面，因為是由作業系統直接提供的，所以不同的作業系統他們所提供的system call介面可能不同。</p>
<h3 id="library-function"><a href="#library-function" class="headerlink" title="library function"></a>library function</h3><p>作業系統會提供另一種方式，將很多過程封裝成一些常用的函式，比如說，一個寫入的函式可能包含很多記憶體、硬碟的操作。<br>而所謂的符合POSIX其實就是指:</p>
<blockquote>
<p>這些函式需要輸入的參數、型別、回傳值等都符合POSIX要求的規範</p>
</blockquote>
<p>根據下圖你就能看到事實上其實一個function可能封裝了system call在其中，那這樣可以帶來什麼好處呢?<br><img src="https://i.imgur.com/FGJlGxm.png"></p>
<h3 id="使用library-function的好處"><a href="#使用library-function的好處" class="headerlink" title="使用library function的好處"></a>使用library function的好處</h3><ol>
<li>節省成本: 會這樣說的原因，需要回到前幾天談過的Kernel mode，當我們使用system call的時候其實會經過mode的轉換，這其實需要一些成本，我們可能會接著問，那library也會使用system call不會嗎?當然會，所以我們的角度會變成，盡可能在進入kernel mode時完成大部分的system call。</li>
<li>可移植: 回到原本談得移植性，當我們的Program是用符合POSIX標準的library與硬體溝通時，這代表這段程式碼可以被直接搬到一樣符合標準的系統，就算這些不同的library內部實現這些介面的方式不同，但這並不是開發人員在乎的事情。不過如果是直接使用system call呢?假如兩邊使用的參數或甚至名稱不同，那段就要經過檢查後重寫…</li>
</ol>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這次的學習解答了為什麼我們在Linux或是其他類Unix的系統上所使用的script大部分都無法搬到windows上使用XD<br>而且通過資料，也看到windows從windows NT原本也期望符合POSIX，但最終放棄，他目前是改為面對開發人員，推出了wsl(Windows Subsystem for Linux)。</p>
<p>到今天為止總算在OS overview的部分告一段落了，後面幾天開始就是DB的一些overview囉!<br>明天見~~</p>
<p>本文章同步發布於<a href="https://tim80411.github.io/code-blog/2022/09/28/OS_POSIX_Basics/">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>閒聊一下，我在寫這天的內容時，使用的正是wsl2，一般而言他還是蠻好用的，他讓我們可以在windows有好用的GUI基礎上，可以透過vscode或是terminal實現類似在linux上開發的感受，我個人覺得是可行的。<br>不過今天也出現問題，在複製照片想貼進md文件時出現了錯誤，看來是在同步剪貼簿時對於照片的轉換出現了問題…</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.baeldung.com/linux/posix">A Guide to POSIX</a><br><a href="https://unix.stackexchange.com/questions/11983/what-exactly-is-posix/220877#220877">What exactly is POSIX?</a><br><a href="https://zhuanlan.zhihu.com/p/392588996">posix是什麼都不知道，還好意思說你懂Linux</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>POSIX</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(中)-執行緒管理</title>
    <url>/code-blog/2022/09/23/OS_Thread/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天會討論執行緒Thread，是一個我覺得很容易跟行程Process混淆的概念，為了學習跟整理這個概念，我們可以踩在前人的肩膀上前進XD</p>
<p>透過一張別人整理出來的Process、Thread比較圖，我們來問問一些「為什麼?」。<br>而透過回答經過整理的問題，可以看到兩者的差別及是什麼造成這些差別。</p>
<p>而最後我相信通過探究這些差異的過程，不只可以幫助理解Thread，也同時可以回頭幫助了解Process~</p>
<span id="more"></span>

<h2 id="執行緒Thread"><a href="#執行緒Thread" class="headerlink" title="執行緒Thread"></a>執行緒Thread</h2><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="left">Process</th>
<th align="left">Thread</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定義</td>
<td align="left">在執行中的程式</td>
<td align="left">行程的一部分</td>
</tr>
<tr>
<td align="left">輕量</td>
<td align="left">不輕量</td>
<td align="left">輕量</td>
</tr>
<tr>
<td align="left">終止時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">建立時間</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">溝通</td>
<td align="left">行程間的溝通較費力且相對Thread來說更久</td>
<td align="left">溝通容易且相對較短</td>
</tr>
<tr>
<td align="left">上下文交換</td>
<td align="left">較長</td>
<td align="left">較短</td>
</tr>
<tr>
<td align="left">資源 (CPU時間)</td>
<td align="left">消耗較多資源</td>
<td align="left">較少</td>
</tr>
<tr>
<td align="left">記憶體</td>
<td align="left">幾乎隔離</td>
<td align="left">有共享的記憶體位置</td>
</tr>
<tr>
<td align="left">資料共用</td>
<td align="left">不共用資料</td>
<td align="left">共享資料</td>
</tr>
<tr>
<td align="left">from <a href="https://www.guru99.com/difference-between-process-and-thread.html">Process vs Thread – Difference Between Them</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="為什麼說Thread是Process的一部分"><a href="#為什麼說Thread是Process的一部分" class="headerlink" title="為什麼說Thread是Process的一部分?"></a>為什麼說Thread是Process的一部分?</h3><p>我們可以用三種角度來看這個定義，看能不能釐清他們!</p>
<h4 id="角度1-工廠藍圖想像"><a href="#角度1-工廠藍圖想像" class="headerlink" title="角度1: 工廠藍圖想像"></a>角度1: 工廠藍圖想像</h4><p>我們先用比較淺顯的想像開頭:</p>
<blockquote>
<p>想像我們按照「藍圖」建立「工廠」，「工廠」裡面會聘請「工人」來完成工作。</p>
</blockquote>
<p>上面提到的藍圖、工廠、工人分別就是Program、Process、Thread。<br>所以實際上完成功作的是作為工人的Thread。</p>
<p>但這邊我在看的時候產生一個困惑，我們在操作系統簡介不是曾說: </p>
<blockquote>
<p>Process會根據CPU scheduling機制搶占CPU資源</p>
</blockquote>
<p>這樣到底是Process還是Thread完成工作呢?</p>
<p>其實這句話依舊是正確的，只是說的還不夠多，要了解這點，我們需要先知到Thread到底是什麼又存在哪裡。</p>
<p>透過一張圖的幫忙會更容易理解了。</p>
<h4 id="角度2-單執行緒行程-vs-多執行緒行程"><a href="#角度2-單執行緒行程-vs-多執行緒行程" class="headerlink" title="角度2: 單執行緒行程 vs 多執行緒行程"></a>角度2: 單執行緒行程 vs 多執行緒行程</h4><p><img src="https://i.imgur.com/Np4e2XK.png"></p>
<blockquote>
<p>from <a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">程序、行程(process)</a></p>
</blockquote>
<p>這是一張單執行緒Process與多執行緒Process的比較圖。<br>我們回到表格中的定義:</p>
<blockquote>
<p>執行緒是行程的一部分</p>
</blockquote>
<p>這樣是不是就很明顯地看到這個定義了呢?<br>執行緒確實是行程的一部分，於是昨天提到的行程結構，其實就是一個單執行緒行程。</p>
<p>確切來說，執行緒的結構包含獨立的: stack、register、counter<br>並且與其他Thread共用code, date(共用變數區), files。</p>
<p>正因為每個Thread有自己的Register、Counter、Stack，所以他們可以自己決定執行哪段程式，也就是說:</p>
<blockquote>
<p>每段執行緒可以執行各自片段的程式碼以完成Process需要完成的工作</p>
</blockquote>
<h4 id="角度3-概念總結"><a href="#角度3-概念總結" class="headerlink" title="角度3: 概念總結"></a>角度3: 概念總結</h4><p>最後來整理一下，並帶到最後一個對Thread及Process之間差異的描述:</p>
<blockquote>
<p>Process是OS分配資源之對象單位，而Thread才是OS分配CPU時間之對象單位<br>  – <a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a></p>
</blockquote>
<h3 id="為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少"><a href="#為什麼Thread相對輕量-建立及終止時間相對短-資源消耗較少" class="headerlink" title="為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?"></a>為什麼Thread相對輕量?建立及終止時間相對短?資源消耗較少?</h3><!-- 建立Thread就像在固定好，且較小的範圍建立資料 -->
<p>Process建立流程包括:</p>
<ol>
<li>向系統註冊，讓系統紀錄執行清單，並標上PID。</li>
<li>分配適當的資源，包含CPU使用權及獨立的資料儲存空間。</li>
</ol>
<p>這個過程會申請空白PCB並初始化資料並填入PCB。</p>
<p>而因為Thread共用了大部分Process的狀態(這邊幫助你回憶一下，Thread是Process的一部分XD)，所以可以減少建立及管理的開銷。<br>另外一部分牽涉到Context Switch的成本，因為行程在進行Context Switch時，需要保存整個Process的狀態資訊，包括Counter、CPU registers、PCB，在處理這個過程花費的CPU相對Thread較多，因為Thread僅需要保存他自己的CPU register而已。</p>
<p>用工廠的說法來描述這些成本的差異好了。<br>建一個工廠需要選地址、找監督特別記錄所有工廠的資料、建立所有流程；而多請一個員工，因為原本的工廠裡面的流程都還在，所以大部分要做的事情都可以被省略。</p>
<h3 id="為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行"><a href="#為什麼Thread溝通容易-為什麼Thread可以共享資料-又為什麼Process不行" class="headerlink" title="為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?"></a>為什麼Thread溝通容易?為什麼Thread可以共享資料?又為什麼Process不行?</h3><p>一個相同行程裡面多個Thread在被建立時，都可以共用同一個Process裡面的區塊的資料，這個區塊就是Heap，可以把這個區塊理解成像是全域變數的存在。</p>
<p>而不同Process在被建立時，他們彼此之間就會被分配不同的記憶體位置，因為沒有共用記憶體，所以Process之間如果需要溝通就要靠其他方法，一般統稱這些方法為Inter-process communication(IPC)，而這個過程相對不易，但也確保了行程內的資料不易被汙染。</p>
<p>盡可能保持Process之間的獨立性是有它的意義的，就好像我們現在可以毫無猶豫的ctrl + alt + delete直接強制關閉行程卻不用擔心造成其他行程的影響，因為他們之間互不依賴。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>透過了解Thread，我們進一步釐清了Thread這個概念被建立想要去處理的問題是快速的多工，並提高了資源(CPU、Memory…)的使用率。<br>於是接下來會進到下集，我們要談的Concurrency，可以說Thread幾乎是為此而生XD至於為什麼這麼說，下一篇也會試圖解釋這件事情!<br>那就明天見囉~</p>
<p>本文章同步分享於<a href="">部落格</a>，歡迎來逛逛~</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>其實原本是要將內容分成上下兩個部分，但Process、Thread、Concurrency這三個主題實在太息息相關，可以講的東西又太多了。<br>不知不覺，篇幅就大到一天要讀完太過難受，為了閱讀體驗<del>以及我的鐵人賽挑戰</del>，所以最終才分成三篇。<br>另外，若有人看不懂本篇的內容的話，可以回頭從<a href="https://ithelp.ithome.com.tw/articles/10295580">OS overview</a>開始看起喔。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://chenhh.gitbooks.io/parallel_processing/content/process.html#%E8%A1%8C%E7%A8%8B%E7%8B%80%E6%85%8Bprocess-state">行程及執行緒</a><br><a href="https://www.quora.com/Why-are-threads-considered-cheap">Why Thread Considered Cheap</a><br><a href="https://stackoverflow.com/questions/1897993/what-is-the-difference-between-concurrent-programming-and-parallel-programming">What is the difference between concurrent programming and parallel programming?</a><br><a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">程序(進程)、執行緒(線程)、協程，傻傻分得清楚！</a><br><a href="https://noob.tw/operating-system-multitasking/">作業系統筆記(二)：利用處理程序、執行緒來多工處理</a><br><a href="https://hackmd.io/@sysprog/linux-process">Linux 核心設計: 不僅是個執行單元的 Process</a><br><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.geeksforgeeks.org/threads-and-its-types-in-operating-system/">Threads and its types in Operating System</a><br><a href="https://medium.com/@yovan/os-process-thread-user-kernel-%E7%AD%86%E8%A8%98-aa6e04d35002">OS Process &amp; Thread (user&#x2F;kernel) 筆記</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Thread</tag>
        <tag>Process</tag>
      </tags>
  </entry>
  <entry>
    <title>行程(Process)、執行緒(thread)傻傻分不清楚(下)-並發(concurrency)</title>
    <url>/code-blog/2022/09/24/OS_concurrency/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>並發Concurrency也是一個常在開發中聽到的名詞，他跟並行Parallel有什麼差別呢?他能夠給系統帶來什麼好處?又有什麼風險需要注意?我們常聽到js是個單執行緒的語言，這又是什麼意思?node.js是單執行緒嗎?</p>
<p>這就是今天會希望解答的問題，那就開始吧~</p>
<span id="more"></span>

<h2 id="Concurrency-vs-Parallel"><a href="#Concurrency-vs-Parallel" class="headerlink" title="Concurrency vs Parallel"></a>Concurrency vs Parallel</h2><p>雖然我們今天的主題談的是Concurrency(並發)，但通常會與Parallel(並行)作個比較。</p>
<p><img src="https://i.imgur.com/kPV2fk8.png"></p>
<p>這是我在找資料學習時最喜歡的一張圖，我覺得他比較正確的視覺化Concurrency及Parallel的定義及關係。<br>邊對照圖片，我們邊看這兩者的定義</p>
<ul>
<li>Concurrency: 多件事可以在一段時間內同時進行</li>
<li>Parallel: 有多件事可以在一個時間點同時進行</li>
</ul>
<p>看起來很像對吧，雖然兩邊都是講同時，但他們對於時間的粒度不太相同，我覺得用排除法去想這件事情比較容易:</p>
<blockquote>
<p>當我們在判斷現在是什麼狀況時，先看<strong>某一個瞬間</strong>可不可以有多個任務同時進行，有的話那就是Parallel；若否，再看<strong>一段時間軸</strong>內可不可以有多件事情同時進行，那就是Concurrency。</p>
</blockquote>
<p>這也是圖片說的，如果一個系統內可以作到Parallel，那他必定也是Concurrency。<br>另外從圖裡面的CPU的表示也能看到，一般而言(註1)一個CPU同時只能被分配給一個thread，在這個狀況下，只有多CPU的狀況才能出現Parallel，這也是為什麼今天我們只先討論Concurrency。</p>
<p>註1: 除非今天CPU支援Hyper-threading(超執行緒)。</p>
<h2 id="Multi-process-Multi-thread-都擠"><a href="#Multi-process-Multi-thread-都擠" class="headerlink" title="Multi process, Multi thread 都擠?"></a>Multi process, Multi thread 都擠?</h2><p>根據Concurrency的定義其實我們可以有兩種Concurrency的方法，一個是多執行緒，一個是多行程，他們都會有多個執行緒讓CPU得以分配時間在他們身上。<br>不過如果你有從昨天一路看下來，就會發現，多行程是一個非常大的成本花費，我們也可以有一個結論，基本上除非你希望資源被隔離得很徹底，不然在Concurrency上，我們應該盡可能使用多執行緒去作Concurrency。</p>
<p>這邊就有一個例子，大部分的web server在接受到新的request時，是不用等待前面的請求結束對吧?一般而言，都是建立thread去處理請求而非process，然後結束時就立刻把thread terminate。</p>
<p>再來我們試著用反例想想，如果我們是以建立process的方式來處理多請求同時出現會發生什麼狀況?<br>第一可能會在建立process就花一點時間，當處理完請求後，又會遇到一個難題是要不要把Process砍掉，如果砍掉下次建立又要花時間，但是不砍掉，他會霸佔部分記憶體資源無法使用，如果有某個請求需要超過原本的記憶體大小，就可能造成memory leak。</p>
<p>當然也有使用多Process的例子，根據這篇資料:</p>
<blockquote>
<p>Google had to decide how to handle that separation of tasks. They chose to run each browser window in Chrome as a separate process rather than a thread or many threads, as is common with other browsers.<br>– <a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/">What’s the Diff: Programs, Processes, and Threads</a></p>
</blockquote>
<p>Google決定選擇使用多進程的原因可以在內文詳看，但他們認為這可以減少最終對於記憶體的使用。</p>
<h2 id="並發的好處"><a href="#並發的好處" class="headerlink" title="並發的好處"></a>並發的好處</h2><p>於是我們可以來整理一下，使用並發的好處包括有什麼呢?(無論Process或是Thread)</p>
<ul>
<li>性能提升: 能夠做到並發的系統，多個Process在運行時的總時間 &lt;&#x3D;(註1) 順序運行Process的總時間。</li>
<li>多程式應付可能: 透過CPU scheduling可以讓系統體感像是多個程式在同時進行一樣。</li>
<li>資源利用: 減少CPU閒置。</li>
</ul>
<p>額外補充，若使用多Thread相對多Process處理並發的好處有什麼呢: </p>
<ul>
<li>Parallel的可能性: 我們前面談的是單核心處理多Thread的狀況，但如果假使是在一個多Processor(多核心、單核心超執行緒…等等)的架構中，經過規劃的多執行緒程式可以在一個時間點同時進行多個Thread的工作，讓並行得以發生。</li>
<li>專業化: 我們可以把工作分門別類產生多個Thread去處理特定工作，甚至可以管理Thread，像是可以去管理Thread的優先層級。</li>
<li>高效: 前面也提到過，Thread相對Process，建立成本低、資料分享容易、資源利用度高，這都是相對多Process高效的原因。</li>
</ul>
<p>註1: 假如這邊範例中的多個process都僅需要CPU運算，因為沒有速率差異導致的閒置問題，那執行併發跟順序執行，總時間都會相同。</p>
<h2 id="並發的風險"><a href="#並發的風險" class="headerlink" title="並發的風險"></a>並發的風險</h2><p>除了好處，事實上多執行緒有許多因為共用資源等特性產生的風險需要在開發時顧慮:</p>
<ul>
<li><p>競爭race condition:<br>正因為共用資料，當出現I&#x2F;O或其他不可控的時間或順序事情時，有可能導致順序依賴的錯誤。<br>例如: 有個變數x &#x3D; 3，兩個共用資源的程式可能有兩個操作 x &#x3D; x + 2, x &#x3D; x + 3，結果意外出現5或6，但原本預期最後結果要是8，想像這如果是你的存款XD<br>而且這樣的錯誤又相當難以追蹤，因為並沒有相關錯誤訊息~</p>
</li>
<li><p>死鎖dead lock:<br>當一個Process在等待其他Process釋放手上的資源時。<br>比如P1需要P0手上的disk資源，但此時P0因為讓出CPU給P1，以至於兩者都無法完成工作。</p>
</li>
<li><p>飢餓starvation:<br>當一個Process因為一直被剝奪完成工作需要的資源。<br>比如因為優先權演算法，P0因為其他優先權更高的Process不斷出現而遲遲拿不到CPU運算。</p>
</li>
</ul>
<p>他們最大的差異，死鎖是除非有額外的機制處理，不然兩者是永遠無法完成工作的；而飢餓則是有機會完成工作，只是不知道什麼時候才會完成。</p>
<h2 id="User-Thread-vs-Kernel-Thread"><a href="#User-Thread-vs-Kernel-Thread" class="headerlink" title="User Thread vs Kernel Thread"></a>User Thread vs Kernel Thread</h2><p>並發的內容看起來結束了，但看到這邊還有一長段你就會知道還沒有XD<br>事實上，大部分的操作系統為了介入一般應用程式及管理他們，他們會使用一個叫做Kernel的程式。<br>而這個Kernel也影響了多執行緒行程如何與操作系統工作，由此出現了user thread及kernel thread這兩個概念。<br>我覺得有個更好稱呼他們的方式是user-level thread及kernel-level thread。</p>
<p>於是在比較他們之前我們需要先了解什麼是Kernel及mode。</p>
<h3 id="Kernel-是什麼"><a href="#Kernel-是什麼" class="headerlink" title="Kernel 是什麼?"></a>Kernel 是什麼?</h3><p>所以究竟Kernel是什麼，他產生thread的原因是什麼呢?</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8f/Kernel_Layout.svg"><br>他其實也是一個系統中的一個具有足夠優先權限的Process，負責處理其他Process與硬體之間的溝通。<br>需要他的原因在於與硬體溝通是相當複雜的，他提供了介面讓硬體操作被抽象化。</p>
<blockquote>
<p>嚴格地說，核心並不是電腦系統中必要的組成部分。有些程式可以直接地被調入電腦中執行；這樣的設計，說明了設計者不希望提供任何硬體抽象和作業系統的支援<br>– <a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">維基百科</a></p>
</blockquote>
<p>Kernel會在其他任何Process被載入，讓操作系統得以介入每個Process，這個介入就是讓User-level Thread與Kernel-level Thread綁定在一起。<br>而當User-level Thread需要與硬體溝通，他就會先與Kernel-level Thread溝通，</p>
<h3 id="Kernel-Mode-vs-User-Mode"><a href="#Kernel-Mode-vs-User-Mode" class="headerlink" title="Kernel Mode vs User Mode"></a>Kernel Mode vs User Mode</h3><p>我把他理解成是兩種不同的權限，為什麼需要兩種特權呢?</p>
<blockquote>
<p>為了避免一個使用者的程式修改其他使用者的程式甚至是系統核心， 並且更進一步，讓作業系統可以壟斷所有的硬體資源，大部分的機器(或者 CPU)至少會有二個執行特權(privilege)：Kernel mode (又稱 System mode) 與 User mode。<br>– <a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a></p>
</blockquote>
<p>既然知道這兩者模式的差異，那又跟Kernel有什麼關係呢?</p>
<blockquote>
<p>Kernel mode is the CPU’s “natural” mode, with no restrictions (on x86 CPUS - “ring 0”). User mode (on x86 CPUs - “ring 3”) is when the CPU is instructed to trigger an interrupt whenever certain instructions are used or whenever some memory locations are accessed. This allows the kernel to have the CPU execute specific kernel code when the user tries to access kernel memory or memory representing I&#x2F;O ports or hardware memory such as the GPU’s frame buffer.<br>– <a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a></p>
</blockquote>
<p>大概意思是，在程式要求執行一些動作時，若他不具有特定權限，Kernel也能夠去要求CPU執行一些相對的Kernel code去中斷目前的Process。<br>這樣讓開發者少掉維護或檢查影響到其他的程式的壓力跟錯誤。</p>
<p>如果是web後端，用最優先的middleware來理解Kernel是不是會容易些?</p>
<h3 id="User-Thread-x2F-User-level-Thread"><a href="#User-Thread-x2F-User-level-Thread" class="headerlink" title="User Thread &#x2F; User-level Thread"></a>User Thread &#x2F; User-level Thread</h3><p>擁有user mode權限的thread，透過特定介面的library建立的，OS並不知道他們的存在，但在要工作時，會mapping到Kernel thread上。<br>特性: </p>
<ul>
<li>產生、管理的成本低</li>
<li>舉例像是: POSIX Pthreads, Win32 threads, Java threads</li>
</ul>
<h3 id="Kernel-Thread-x2F-Kernel-level-Thread"><a href="#Kernel-Thread-x2F-Kernel-level-Thread" class="headerlink" title="Kernel Thread &#x2F; Kernel-level Thread"></a>Kernel Thread &#x2F; Kernel-level Thread</h3><p>僅運行kernel code且與user space(memory) process毫無關聯的Thread。<br>並且我們知道thread一定在process之中，而Kernel thread就是Kernel這個Process產生出來的thread</p>
<ul>
<li>CPU能查覺到存在的其實是Kernel-level Thread，而非mapping於他的User-level Thread。</li>
<li>舉例像是: Windows 2000(NT), Solaris, Linux</li>
</ul>
<h2 id="多執行緒模式"><a href="#多執行緒模式" class="headerlink" title="多執行緒模式"></a>多執行緒模式</h2><p>由上，我們會知道，所以在user mode的Process要操作到硬體的部分是需要經過kernel thread。<br>而這個對映的方式稱為mapping，mapping的方式共有三種:</p>
<ul>
<li>多對一</li>
<li>一對一</li>
<li>多對多</li>
</ul>
<h3 id="多對一"><a href="#多對一" class="headerlink" title="多對一"></a>多對一</h3><p><img src="https://i.imgur.com/Sd5bMmQ.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到一個Kernel-level Thread</li>
<li>優點:<ul>
<li>Thread管理在user space(memory)完成，效率高</li>
</ul>
</li>
<li>缺點:<ul>
<li>整個process可能會因為其中一個user thread發出的指令而導致block。</li>
<li>因為OS僅察覺到一個kernel thread，如果在一個以thread數量平分cpu使用使間的系統中，他的單位仍是一。</li>
<li>只有一個thread可以訪問kernel，就算是多processor的環境也無法平行。</li>
</ul>
</li>
</ul>
<h3 id="一對一"><a href="#一對一" class="headerlink" title="一對一"></a>一對一</h3><p><img src="https://i.imgur.com/IxbwdDb.png"></p>
<ul>
<li>定義: 一個User-level Thread mapping到一個Kernel-level Thread</li>
<li>例子: Linux, Windows XP&#x2F;NT&#x2F;2000</li>
<li>優點:<ul>
<li>所有多對一的缺點的相反。</li>
</ul>
</li>
<li>缺點:<ul>
<li>產生一個thread時就同時產生kernel thread，負擔較高</li>
<li>所有的操作都會進行system call，要進行前者的動作，需要將權限改為kernel mode，而這是一個昂貴的操作</li>
</ul>
</li>
</ul>
<h3 id="一對多"><a href="#一對多" class="headerlink" title="一對多"></a>一對多</h3><p><img src="https://i.imgur.com/SHSoik1.png"></p>
<ul>
<li>定義: 多個User-level Thread mapping到多個Kernel-level Thread</li>
<li>優點:<ul>
<li>可在多Processor系統中平行執行。</li>
<li>某個thread被block後可安排其他kernel thread執行</li>
</ul>
</li>
<li>缺點:<ul>
<li>需要user thread 管理器與 kernel thread 管理器支援這種協調。</li>
</ul>
</li>
</ul>
<h2 id="node-js的有趣事實"><a href="#node-js的有趣事實" class="headerlink" title="node.js的有趣事實"></a>node.js的有趣事實</h2><p>關於node.js，他究竟是不是單執行緒的runtime呢?<br>他像是，但其實並不是的。<br>他一共有7個執行緒，包括1個執行JS的主執行緒、4個node.js執行緒、2個V8執行緒。</p>
<h3 id="調查多執行緒的事實"><a href="#調查多執行緒的事實" class="headerlink" title="調查多執行緒的事實"></a>調查多執行緒的事實</h3><p>要證明這件事情其實意外的容易:</p>
<ol>
<li>先做一個可以永久執行的node.js，例如web server或是無限while迴圈之類的</li>
<li>取得PID<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps | grep node</span><br></pre></td></tr></table></figure></li>
<li>查看執行緒<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br><span class="line"># -H可以顯示行程中的執行緒</span><br><span class="line"># -P指定特定PID</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你就可以看到7個執行緒了<br>不過4個node.js的執行緒其實只會做I&#x2F;O相關的工作，如果遇到CPU密集的工作，其實還是會發生JS主執行緒阻塞而導致整個Process阻塞的狀況。</p>
<h3 id="worker-threads-module"><a href="#worker-threads-module" class="headerlink" title="worker-threads module"></a>worker-threads module</h3><p>node.js v12開始支援worker-threads，於是剛剛提到的CPU密集型的工作就可以透過模組建立新的thread去承接這個工作。<br>詳細有興趣的人可以去<a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js"></a>跟著教學一起玩一下，蠻有意思的喔!</p>
<h3 id="cluster-module"><a href="#cluster-module" class="headerlink" title="cluster module"></a>cluster module</h3><p>cluster則是支援建立主Process的child processes，而官方的資料也確實提到，若沒有隔離行程的必要，就使用worker-threads代替。</p>
<blockquote>
<p>Clusters of Node.js processes can be used to run multiple instances of Node.js that can distribute workloads among their application threads. When process isolation is not needed, use the worker_threads module instead, which allows running multiple application threads within a single Node.js instance.<br><a href="https://nodejs.org/api/cluster.html">node.js</a></p>
</blockquote>
<p>不過根據官方文件以及在實務上看到cluster的用法，cluster更像是一種負載平衡的機制，worker-threads則可以用來應付CPU密集的工作，所以我覺得完全有可能混用他們!</p>
<p>也確實有stackoverflow的回答這樣認為~</p>
<blockquote>
<p>Which is better? It depends on the problem you’re solving. Worker threads are for long-running functions. Clustering makes a server able to handle more requests, by handling them in parallel. You can use both if you need to: have each nodejs cluster process use a worker thread for long-running functions.<br><a href="https://stackoverflow.com/questions/61328960/when-is-better-using-clustering-or-worker-threads">When is better using clustering or worker_threads?</a></p>
</blockquote>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>雖然寫的辛苦，但總算對於Program、Process、Thread有了更進一步的了解。<br>而且回過頭來，我覺得這樣我在使用一些與Thread以及Process相關的功能時也能更有把握些。<br>想起第一次面試時，當時考官就問我node.js是否是單執行緒這個問題，結果直到今天我才有辦法稍稍好一點的回答這個問題XD</p>
<h2 id="後話"><a href="#後話" class="headerlink" title="後話"></a>後話</h2><p>發現我用了一些中文單字其實是有中、台兩種說法的，參照<a href="https://oldmo860617.medium.com/%E9%80%B2%E7%A8%8B-%E7%B7%9A%E7%A8%8B-%E5%8D%94%E7%A8%8B-%E5%82%BB%E5%82%BB%E5%88%86%E5%BE%97%E6%B8%85%E6%A5%9A-a09b95bd68dd">此篇</a>特意列出，避免混淆。</p>
<ul>
<li>concurrent:<ul>
<li>台灣：並行</li>
<li>大陸：並發</li>
</ul>
</li>
<li>parallel:<ul>
<li>台灣：平行</li>
<li>大陸：並行</li>
</ul>
</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10280394">PPT in Operating system</a><br><a href="https://www.kshuang.xyz/doku.php/operating_system:course_concept:thread">Thread</a><br><a href="https://hackmd.io/@Chang-Chia-Chi/OS-CH4">作業系統 CH4 Multithreaded Programming</a><br><a href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">Difference between user-level and kernel-supported threads?</a><br><a href="https://stackoverflow.com/questions/57160637/difference-between-kernel-kernel-thread-and-user-thread">Difference between Kernel, Kernel-Thread and User-Thread</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E6%A0%B8">核心</a><br><a href="https://medicineyeh.wordpress.com/2015/02/10/kernel-mode-%E8%88%87-user-mode-%E7%9A%84%E6%A6%82%E5%BF%B5/">Kernel Mode 與 User Mode 的概念</a><br><a href="https://medium.com/@akhandmishra/operating-system-threads-and-concurrency-aec2036b90f8">Operating System: Threads and Concurrency</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js">https://www.digitalocean.com/community/tutorials/how-to-use-multithreading-in-node-js</a><br><a href="https://blog.appsignal.com/2021/02/03/improving-node-application-performance-with-clustering.html">Improving Node.js Application Performance With Clustering</a></p>
]]></content>
      <tags>
        <tag>鐵人賽</tag>
        <tag>OS</tag>
        <tag>Thread</tag>
        <tag>Process</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
</search>
